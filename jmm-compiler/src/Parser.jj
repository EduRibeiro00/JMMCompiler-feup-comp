options {
    LOOKAHEAD = 1;
}
PARSER_BEGIN(Parser)

public class Parser {

}

PARSER_END(Parser)


SKIP: {
    " " | "\t" | "\r" | "\n"
}

TOKEN: {
    <IF: "if" >
    | <ELSE: "else" >
    | <PUBLIC: "public" >
    | <NEW: "new" >
    | <INT: "int" >
    | <TRUE: "true" >
    | <THIS: "this" >
    | <FALSE: "false" >
    | <CLASS: "class" >
    | <LENGTH: "length" >
    | <RETURN: "return" >
    | <IMPORT: "import" >
    | <BOOLEAN: "boolean" >
    | <EXTENDS: "extends" >
    | <WHILE: "while" >
    | <LBRACKET: "{" >
    | <RBRACKET: "}" >
    | <LPAR: "(" >
    | <RPAR: ")" >
    | <LSQRBRACKET: "[" >
    | <RSQRBRACKET: "]" >
    | <SCOLON: ";" >
    | <COMMA: "," >
    | <EQUALS: "=" >
    | <AND: "&&" >
    | <LESS: "<" >
    | <PLUS: "+" >
    | <MINUS: "-" >
    | <MUL: "*" >
    | <DIV: "/" >
    | <DOT: "." >
    | <NOT: "!" >
    | <IDENTIFIER: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z", "0"-"9", "_"])* >
    | <INTEGERLITERAL: (["0"-"9"])+ >
}

void Program() : {}
{
    ImportDeclaration() ClassDeclaration() <EOF>
}

void ImportDeclaration() : {}
{
    (<IMPORT>)*
}

void ClassDeclaration() : {}
{
    <CLASS>
    <IDENTIFIER>
    (<EXTENDS> <IDENTIFIER>)?
    <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
    <RBRACKET>
}

void VarDeclaration() : {}
{
   Type() <IDENTIFIER> <SCOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC>
    Type()
    <IDENTIFIER>
    <LPAR>
    (
        Type() <IDENTIFIER>
        (<COMMA> Type() <IDENTIFIER>)*
    )?
    <RPAR>
    <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    <RETURN> Expression() <SCOLON>
    <RBRACKET>
}

void Type() : {}
{
    LOOKAHEAD(2) <INT> <LSQRBRACKET> <RSQRBRACKET>
    |
    <BOOLEAN>
    |
    <INT>
    |
    <IDENTIFIER>
}

void Statement() : {}
{
    <LBRACKET> (Statement())* <RBRACKET>
    |
    <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    |
    <WHILE> <LPAR> Expression() <RPAR> Statement()
    |
    LOOKAHEAD(2) <IDENTIFIER> <EQUALS> Expression() <SCOLON>
    |
    LOOKAHEAD(2) <IDENTIFIER> <LSQRBRACKET> Expression() <RSQRBRACKET> ArrayAssignment() <SCOLON>
    |
    Expression() <SCOLON>
}

void ArrayAssignment() : {}
{
    <EQUALS> Expression()
    |
    ExpressionFragment()
}

void Expression() : {}
{
    <INTEGERLITERAL> ExpressionFragment()
    |
    <TRUE> ExpressionFragment()
    |
    <FALSE> ExpressionFragment()
    |
    <IDENTIFIER> ExpressionFragment()
    |
    <THIS> ExpressionFragment()
    |
    LOOKAHEAD(2) <NEW> <INT> <LSQRBRACKET> Expression() <RSQRBRACKET> ExpressionFragment()
    |
    <NEW> <IDENTIFIER> <LPAR> <RPAR> ExpressionFragment()
    |
    <NOT> Expression() ExpressionFragment()
    |
    <LPAR> Expression() <RPAR> ExpressionFragment()
}

void ExpressionFragment() : {}
{
    (<AND> | <LESS> | <PLUS> | <MINUS> | <MUL> | <DIV>) Expression() ExpressionFragment()
    |
    <LSQRBRACKET> Expression() <RSQRBRACKET> ExpressionFragment()
    |
    LOOKAHEAD(2) <DOT> <LENGTH> ExpressionFragment()
    |
    <DOT> <IDENTIFIER> <LPAR> (Expression() (<COMMA> Expression())*)? <RPAR> ExpressionFragment()
    |
    {}
}
