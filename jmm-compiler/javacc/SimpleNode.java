import exceptions.SemanticParseException;
import java.util.Set;
import java.util.List;
import java.util.Map;
import java.util.List;
import java.util.BitSet;

/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class SimpleNode implements Node {

	protected SimpleNode parent;
	protected SimpleNode[] children;
	protected int id;
	protected Object value;
	protected Parser parser;
	protected Token firstToken;
	protected Token lastToken;
	protected String returnType;

	protected Integer calcValue = null;

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(Parser p, int i) {
		this(i);
		parser = p;
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		parent = (SimpleNode) n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new SimpleNode[i + 1];
		} else if (i >= children.length) {
			SimpleNode c[] = new SimpleNode[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = (SimpleNode) n;
	}

	public SimpleNode jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	public void jjtSetValue(Object value) {
		this.value = value;
	}

	public Object jjtGetValue() {
		return value;
	}

	public Token jjtGetFirstToken() {
		return firstToken;
	}

	public void jjtSetFirstToken(Token token) {
		this.firstToken = token;
	}

	public Token jjtGetLastToken() {
		return lastToken;
	}

	public void jjtSetLastToken(Token token) {
		this.lastToken = token;
	}

	/**
	 * Get Node return type
	 * @return String with node return type
	 */
	public String getReturnType(){
		return this.returnType;
	}

	/**
	 * Get SimpleNode Value
	 * @return Null if isn't assigned with a value or int (0/1 to booleans)
	 */
	public Integer getCalcValue(){
		return this.calcValue;
	}

	/*
	 * You can override these two methods in subclasses of SimpleNode to customize
	 * the way the node appears when the tree is dumped. If your output uses more
	 * than one line you should override toString(String), otherwise overriding
	 * toString() is probably all you need to do.
	 */

	public String toString() {
		switch (ParserTreeConstants.jjtNodeName[id]) {
			case "Type":
			case "Boolean":
			case "Identifier":
			case "Numeric":
			case "Method":
			case "Import":
			case "Class":
			case "Extends":
				return ParserTreeConstants.jjtNodeName[id] + "[" + this.value + "]";
			default:
				return ParserTreeConstants.jjtNodeName[id];
		}
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/*
	 * Override this method if you want to customize how the node dumps out its
	 * children.
	 */

	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.dump(prefix + "    ");
				}
			}
		}
	}

	public int getId() {
		return id;
	}

	/**
	 * Recursive Function resposible for the Semantical analysis
	 *
	 * @param descriptor SimbolTable
	 * @param variables Variable set to help set the initialization
	 * @return Node type
	 * @throws SemanticParseException
	 */

	public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException {
		return "";
	}

	/**
	 * Recursive Function resposible for the code generation
	 *
	 * @param descriptor SimbolTable
	 */
  	public void generateCode(Descriptor descriptor){
		return;
	}

	/**
	 * Replace old node argument with the new one
	 *
	 * @param oldNode Node to be replaced
	 * @param newNode New node to replace the first one
	 */
	public void replaceChild(SimpleNode oldNode, SimpleNode newNode) {
		for (int i = 0; i < children.length; i++) {
			if (children[i] == oldNode) {
				children[i] = newNode;
			}
		}
	}

	/**
	 * Recursive function that helps to perform the -o optimization
	 *
	 * @param descriptor SimbolTable
	 * @param variables Map of variable (or array) name to index (in arrays) or # (default for variables and length for arrays) to its value
	 */
	public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
		for (int i = 0; i < this.jjtGetNumChildren(); i++)
			this.jjtGetChild(i).optimize(descriptor, variables);
  	  	return;
	}

	/**
	 * Recursive function that helps to perform the -r optimization
	 *
	 * @param descriptor SimbolTable
	 */
	public void optR(Descriptor descriptor){
		for (int i = 0; i < this.jjtGetNumChildren(); i++)
			this.jjtGetChild(i).optR(descriptor);
		return;
	}


	/**
	 * Method that helps and takes part in the generation of the CFG for the liveness analysis, used for the register allocation in the -r optimization.
	 *
	 * @param use List of BitSets that contain which local variables are used in each node of the CFG
	 * @param def List of BitSets that contain which local variables are defined in each node of the CFG
	 * @param succ List of BitSets that contain which are the successors (if any) for each node of the CFG
	 * @param mDescriptor Method descriptor of the method in which the liveness analysis is being performed
	 */
	public void generateCFG(List<BitSet> use, List<BitSet> def, List<BitSet> succ, MethodDescriptor mDescriptor) {
		BitSet useNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet defNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet succNode = new BitSet();

		for (int i = 0; i < this.jjtGetNumChildren(); i++)
			this.jjtGetChild(i).generateCFGNode(useNode, defNode, false, mDescriptor);

		use.add(useNode);
		def.add(defNode);
		succ.add(succNode);
		succNode.set(succ.size());
	}

	/**
	 * Method that generates a CFG node corresponding in an instructor of the method, that uses and/or defines local variables. Used in the -r optimization.
	 *
	 * @param useNode BitSet that contains (or will contain) indication of the local variables that are used in this node of the CFG
	 * @param defNode BitSet that contains (or will contain) indication of the local variables that are defined in this node of the CFG
	 * @param varDef Flag that indicates if the variable is being defined (true) or used (false)
	 * @param mDescriptor Method descriptor of the method in which the liveness analysis is being performed
	 */
	public void generateCFGNode(BitSet useNode, BitSet defNode, boolean varDef, MethodDescriptor mDescriptor) {
		for (int i = 0; i < this.jjtGetNumChildren(); i++)
			this.jjtGetChild(i).generateCFGNode(useNode, defNode, varDef, mDescriptor);
	}

	public boolean hasMethodCallInside() {
		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			boolean hasInside = this.jjtGetChild(i).hasMethodCallInside();
			if (hasInside)
				return true;
		}

		return false;
	}
}

/*
 * JavaCC - OriginalChecksum=15789662d930da128363c781bfbf49fb (do not edit this
 * line)
 */
