import exceptions.SemanticParseException;
import java.util.Set;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.List;
import java.util.BitSet;
import enums.ConditionType;



/* Generated By:JJTree: Do not edit this line. ASTWhile.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTWhile extends SimpleNode {
    private ConditionType type = ConditionType.Undefined;
    public ASTWhile(int id) {
        super(id);
    }

    public ASTWhile(Parser p, int id) {
        super(p, id);
    }

    @Override
    public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException {
        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
        try {
            this.jjtGetChild(0).analyze(methodDescriptor, variables);
        } catch (SemanticParseException ex) {

        }

        try {
            Set<String> cloned = new HashSet<String>(variables);
            this.jjtGetChild(1).analyze(descriptor, cloned);
            for (String variable : cloned)
                methodDescriptor.searchVariable(variable).setProgression();
        } catch (SemanticParseException ex) {

        }

        return "";
    }

    public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

        this.jjtGetChild(0).optimize(descriptor, variables);

        if(this.jjtGetChild(0).getCalcValue() != null && this.jjtGetChild(0).getCalcValue() == 1)
            this.type = ConditionType.True;
        else if(this.jjtGetChild(0).getCalcValue() != null && this.jjtGetChild(0).getCalcValue() == 0){
            this.type = ConditionType.False;
            return;
        }

        Map<String, Set<Integer>> assignmentsBeforeWhile = new HashMap<>();
        for (String variable : variables.keySet()) {
            // if(variables.get(variable).get("#") == null)
            //     continue;
            VariableDescriptor varDesc = methodDescriptor.getVariable(variable);
            if (varDesc != null) {
                Set<Integer> assignments = varDesc.getAssignmentsForNextUsage();
                assignmentsBeforeWhile.put(variable, assignments);
            }
        }

        // Perform constant propagation like an independent function
        Map<String, Map<String, Integer>> clean = new HashMap<String, Map<String, Integer>>();
        clean.put("#cond#", new HashMap<String, Integer>());
        this.jjtGetChild(1).optimize(descriptor, clean);
        clean.remove("#cond#");
        // Clone variables
        Map<String, Map<String, Integer>> clone = new HashMap<String, Map<String, Integer>>();
        for (Map.Entry<String, Map<String, Integer>> entry : variables.entrySet()) {
            clone.put(entry.getKey(),  (Map<String, Integer>) ((HashMap<String, Integer>) variables.get(entry.getKey())).clone());
        }

        // Remove
        for(String name : clean.keySet()){
            Map<String, Integer> prov = clone.get(name);
            if(prov == null)
                continue;
            for(String id : clean.get(name).keySet())
                prov.remove(id);
            clone.put(name, prov);
        }

        Map<String, Map<String, Integer>> clone2 = new HashMap<String, Map<String, Integer>>();
        for (Map.Entry<String, Map<String, Integer>> entry : clone.entrySet()) {
            clone2.put(entry.getKey(),  (Map<String, Integer>) ((HashMap<String, Integer>) clone.get(entry.getKey())).clone());
        }



        // Variables has the untouch variables, so we can assign those
        this.jjtGetChild(0).jjtGetChild(0).optimize(descriptor, clone);
        this.jjtGetChild(1).optimize(descriptor, clone);
        this.jjtGetChild(0).jjtGetChild(0).optimize(descriptor, clone2);


        for(String name : clean.keySet()){
            Map<String, Integer> mapBef = variables.get(name) != null ? variables.get(name) : new HashMap<String, Integer>();
            Map<String, Integer> mapInside = clone.get(name);

            for(String id : clean.get(name).keySet()){
                Integer valueBef = mapBef.get(id);
                Integer valueInside = mapInside != null ? mapInside.get(id) : null;

                if(this.type == ConditionType.Undefined){
                    if(valueBef != valueInside)
                        mapBef.remove(id);
                }
                else{
                    mapBef.put(id, valueInside);
                }


                // if there's possibility of entering the loop, then last asignment made before entering loop
                // may be necessary in the future
                if (this.type == ConditionType.Undefined) {
                    if(!id.equals("#"))
                        continue;
                    VariableDescriptor variableDescriptor = methodDescriptor.getVariable(name);
                    if (variableDescriptor != null) {
                        Set<Integer> neededAssignments = assignmentsBeforeWhile.get(name);

                        if (neededAssignments != null) {
                            variableDescriptor.addAssignmentsForNextUsage(neededAssignments);
                        }
                    }
                }
            }
            variables.put(name, mapBef);
        }
	}

    @Override
    public void generateCode(Descriptor descriptor) {
        if(ConditionType.False == this.type)
            return;
        int whileNumber = JVMHelper.getWhileLabel();

        parser.addInstruction(new JVMInstruction("WHILE_" + whileNumber + ":",0));
        if(ConditionType.Undefined == this.type){
            // Generate Condition
            if(this.jjtGetChild(0).jjtGetChild(0) instanceof ASTLess)
                this.generateLessCondition(descriptor, whileNumber, true);
            else{
                this.jjtGetChild(0).generateCode(descriptor);
                parser.addInstruction(new JVMInstruction("ifeq END_WHILE_" + whileNumber,-1));
            }

            // Generate Body
            this.jjtGetChild(1).generateCode(descriptor);
            if(!(this.jjtGetChild(1) instanceof ASTScope)){
                if(! (this.jjtGetChild(1) instanceof ASTVarDeclaration)){

                    // Add a pop to avoid leaving "stray" elements on the stack
				    if(this.jjtGetChild(1) .getReturnType() != null && this.jjtGetChild(1).getReturnType() != "void" )
					    parser.addInstruction(new JVMInstruction("pop",-1));
                }
            }

            parser.addInstruction(new JVMInstruction("goto WHILE_" + whileNumber,0));
            parser.addInstruction(new JVMInstruction("END_WHILE_" + whileNumber + ":",0));
            return;
        }
        // Body
        this.jjtGetChild(1).generateCode(descriptor);
        if(!(this.jjtGetChild(1) instanceof ASTScope)){
            if(! (this.jjtGetChild(1) instanceof ASTVarDeclaration)){
                if(this.jjtGetChild(1) .getReturnType() != null && this.jjtGetChild(1).getReturnType() != "void" )
                    parser.addInstruction(new JVMInstruction("pop",-1));
            }
        }

        if(this.jjtGetChild(0).jjtGetChild(0) instanceof ASTLess)
            this.generateLessCondition(descriptor, whileNumber, false);
        else{
            this.jjtGetChild(0).generateCode(descriptor);
            parser.addInstruction(new JVMInstruction("ifne WHILE_" + whileNumber,-1));
        }

    }

	public void generateLessCondition(Descriptor descriptor, int whileLabel, boolean positive) {
        SimpleNode astLess = this.jjtGetChild(0).jjtGetChild(0);
        SimpleNode lhsNode = astLess.jjtGetChild(0);
        SimpleNode rhsNode = astLess.jjtGetChild(1);

        if (lhsNode instanceof ASTNumeric && Integer.parseInt((String) lhsNode.jjtGetValue()) == 0) {
            // 0 < x <=> x > 0 -> x =< 0
            rhsNode.generateCode(descriptor);
            if(positive)
                parser.addInstruction(new JVMInstruction("ifle END_WHILE_" + whileLabel,-1));
            else
                parser.addInstruction(new JVMInstruction("ifgt WHILE_" + whileLabel,-1));
        }
        else if(rhsNode instanceof ASTNumeric && Integer.parseInt((String) rhsNode.jjtGetValue()) == 0){
            // x < 0 -> x >= 0
            lhsNode.generateCode(descriptor);
            if(positive)
                parser.addInstruction(new JVMInstruction("ifge END_WHILE_" + whileLabel,-1));
            else
                parser.addInstruction(new JVMInstruction("iflt WHILE_" + whileLabel,-1));
        }
        else{
            //e < D -> esquerda >= direita
            lhsNode.generateCode(descriptor);
            rhsNode.generateCode(descriptor);
            if(positive)
                parser.addInstruction(new JVMInstruction("if_icmpge END_WHILE_" + whileLabel,-2));
            else
                parser.addInstruction(new JVMInstruction("if_icmplt WHILE_" + whileLabel,-2));
        }
    }

    @Override
    public void generateCFG(List<BitSet> use, List<BitSet> def, List<BitSet> succ, MethodDescriptor mDescriptor) {

        // Generate condition
        ASTCondition cond = (ASTCondition) this.jjtGetChild(0);
        int nodeID = succ.size();
        cond.generateCFG(use, def, succ, mDescriptor);

        // Generate scope
        this.jjtGetChild(1).generateCFG(use, def, succ, mDescriptor);

        // Make last while instruction point to condition
        succ.get(succ.size() - 1).clear();
        succ.get(succ.size() - 1).set(nodeID);

        // Add dummy instruction after the while
        BitSet useBoot = new BitSet(mDescriptor.getLocalsCount());
        BitSet defBoot = new BitSet(mDescriptor.getLocalsCount());
        BitSet succBoot = new BitSet();
        use.add(useBoot);
        def.add(defBoot);
        succ.add(succBoot);

        // Make dummy instruction point forward
        succBoot.set(succ.size());

        // Make condition point to dummy instruction
        succ.get(nodeID).set(succ.size() - 1);

    }
}
/*
 * JavaCC - OriginalChecksum=5f4455af0142b2fe9a424f1a313045fd (do not edit this
 * line)
 */
