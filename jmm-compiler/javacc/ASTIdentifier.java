import java.util.Set;
import java.util.Map;
import enums.Visibility;
import exceptions.SemanticParseException;
import exceptions.VariableUndefinedException;
import java.util.List;
import java.util.BitSet;

/* Generated By:JJTree: Do not edit this line. ASTIdentifier.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTIdentifier extends SimpleNode {
    public ASTIdentifier(int id) {
        super(id);
    }

    public ASTIdentifier(Parser p, int id) {
        super(p, id);
    }

    @Override
    public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException {
        return analyze(descriptor, variables,false);
    }

    public String analyze(Descriptor descriptor, Set<String> variables, boolean methodCall) throws SemanticParseException {
        MethodDescriptor functionST = (MethodDescriptor) descriptor;
        VariableDescriptor se = functionST.searchVariable((String) this.jjtGetValue());

        // Variable not found in method or class
        if (se == null) {
            VariableUndefinedException undefinedException = new VariableUndefinedException(this.jjtGetValue() + " is undefined.");

            // If we are in a methodcall we won't consider this an error because the left side might be an imported class (static invocations)
            if (methodCall)
                throw undefinedException;
            else {
                this.parser.handleSemanticError(undefinedException, this);
                throw undefinedException;
            }
        }

        // Variable initialization data
        if (!se.isInitialized() && !variables.contains(se.getIdentifier())){
            if(se.hadProgression())
                this.parser.handleSemanticError(
                        new SemanticParseException(this.jjtGetValue() + " may not have been initialized before its usage.", false), this);
            else
                this.parser.handleSemanticError(
                        new SemanticParseException(this.jjtGetValue() + " was not initialized before its usage."), this);
        }

        this.returnType = se.getType();
        return this.returnType;
    }

    public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
        if(this.jjtGetNumChildren() > 0){
            super.optimize(descriptor, variables);
            return;
        }
        String variableName = (String) this.jjtGetValue();
        Map<String, Integer> rhs = variables.get(variableName);

        if(rhs == null)
            return;
        Integer constValue = rhs.get("#");

        if (constValue != null) {
            SimpleNode constNode = null;
            if (this.returnType.equals("int")) {
                constNode = new ASTNumeric(this.parser, ParserTreeConstants.JJTNUMERIC);
                constNode.value = constValue.toString();
            } else if(this.returnType.equals("boolean")) {
                constNode = new ASTBoolean(this.parser, ParserTreeConstants.JJTBOOLEAN);
                if (constValue.equals(1))
                    constNode.value = "true";
                else
                    constNode.value = "false";
            }

            // if(variables.get("#cond#") == null)
            if(variables.get("#cond#") == null && constNode != null)
                ((SimpleNode) this.jjtGetParent()).replaceChild(this, constNode);
            else{
                this.calcValue = constValue;
            }
        } else {
            if (variables.get("#cond#") == null && ! (((SimpleNode) this).jjtGetParent() instanceof ASTVarDeclaration)) {
                MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

                VariableDescriptor variableDescriptor = methodDescriptor.getVariable(variableName);
                if (variableDescriptor != null) {
                    variableDescriptor.assignmentUsage();
                }
            }
        }
    }

    @Override
	public void generateCode(Descriptor descriptor) {

        MethodDescriptor functionST = (MethodDescriptor) descriptor;
        VariableDescriptor se = functionST.searchVariable((String) this.jjtGetValue());

        if (se.getVisibility() == Visibility.PUBLIC)
            parser.addInstruction(new JVMInstruction("aload_0", 1));

		parser.addInstruction(JVMHelper.getLoadInstruction(se));
	}

    public void generateCFGNode(BitSet useNode, BitSet defNode, boolean varDef, MethodDescriptor mDescriptor) {
        String variableName = (String) this.jjtGetValue();
        VariableDescriptor vDescriptor = mDescriptor.getVariable(variableName);
        VariableDescriptor vDesc = mDescriptor.searchVariable(variableName);

        // The node uses the "this" local, so set local variable 0
        if(vDesc != null && vDesc.getVisibility() == Visibility.PUBLIC){
            useNode.set(0);
        }

        // Check if it's a variable or a method call
        if (vDescriptor != null)
            if (varDef)
                defNode.set(vDescriptor.getLocalStackPosition());
            else
                useNode.set(vDescriptor.getLocalStackPosition());

        for (int i = 0; i < this.jjtGetNumChildren(); i++) {
            this.jjtGetChild(i).generateCFGNode(useNode, defNode, false, mDescriptor);
        }
    }
}
/*
 * JavaCC - OriginalChecksum=75abfe948da46b0c7b3a59b2cae3a666 (do not edit this
 * line)
 */
