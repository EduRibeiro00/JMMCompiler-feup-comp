import exceptions.SemanticParseException;

import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.BitSet;
import java.util.List;

import enums.Visibility;

/* Generated By:JJTree: Do not edit this line. ASTAssignment.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTAssignment extends SimpleNode {
	private int assignmentID;

	public ASTAssignment(int id) {
		super(id);
		this.assignmentID = 0;
	}

	public ASTAssignment(Parser p, int id) {
		super(p, id);
	}

	@Override
	public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException {
		MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

		SimpleNode lhsNode = this.jjtGetChild(0);
		VariableDescriptor lhs = null;
		String lhsType = "";

		// Left side is identifier
		if(lhsNode instanceof ASTIdentifier){

			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetValue());
			if(lhs == null){

				SemanticParseException ex = new SemanticParseException(lhsNode.jjtGetValue() + " doesn't exist");
				this.parser.handleSemanticError(ex, lhsNode);

				throw ex;
			}

			lhsType = lhs.getType();

		}
		// Left side is array access
		else{
			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetChild(0).jjtGetValue());

			if(lhs == null){

				SemanticParseException ex = new SemanticParseException(lhsNode.jjtGetChild(0).jjtGetValue() + " doesn't exist");
				this.parser.handleSemanticError(ex, lhsNode.jjtGetChild(0));

				throw ex;
			}

			lhsType = lhsNode.analyze(methodDescriptor, variables);
		}

		SimpleNode rhsNode = this.jjtGetChild(1);
		String rhsType = rhsNode.analyze(methodDescriptor, variables);

		// Check if left side and right side types match
		if (!lhsType.equals(rhsType)) {
			String extendedClassName = methodDescriptor.getparentClass().getExtendedClassName();
			if(extendedClassName == null || !extendedClassName.equals(lhsType))
				this.parser.handleSemanticError(new SemanticParseException("Assignment mismatch: " + lhsNode.jjtGetValue() + "[" + lhsType + "]" + " and " + rhsNode.jjtGetValue() + "[" + rhsType + "]"), this);
		}

		// Progression data
		// lhs.setProgression();

		variables.add(lhs.getIdentifier());
		return "";
	}

	public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
		Integer constantValue = null;
		if(!(this.jjtGetChild(0) instanceof ASTIdentifier)){
			this.jjtGetChild(0).optimize(descriptor, variables);
		}

		this.jjtGetChild(1).optimize(descriptor, variables);

		if (this.jjtGetChild(0) instanceof ASTIdentifier) {
			if (this.jjtGetChild(1) instanceof ASTNumeric)
				constantValue = Integer.parseInt((String) this.jjtGetChild(1).value);
			else if (this.jjtGetChild(1) instanceof ASTBoolean) {
				if (((String) this.jjtGetChild(1).value).equals("true")) {
					constantValue = 1;
				} else {
					constantValue = 0;
				}
			}
			// Array
			else{
				constantValue = this.getArraySize();
			}

			String variableName = (String) this.jjtGetChild(0).jjtGetValue();
			Map<String, Integer> rhs = variables.get(variableName);
			rhs = rhs != null ? rhs : new HashMap<String, Integer>();
			rhs.put("#", constantValue);
			variables.put(variableName, rhs);

			if (variables.get("#cond#") == null) {
				MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
				VariableDescriptor variableDescriptor = methodDescriptor.getVariable(variableName);
				if (variableDescriptor != null) {
					this.assignmentID = variableDescriptor.newAssignment();
				}
			}
			return;
		}
		// Array access
		SimpleNode arrayAccess = this.jjtGetChild(0);
		String name = (String) arrayAccess.jjtGetChild(0).jjtGetValue();
		if(arrayAccess.jjtGetChild(1) instanceof ASTNumeric){
			// Name format: name - id
			String index = (String) arrayAccess.jjtGetChild(1).jjtGetValue();

			if(this.jjtGetChild(1) instanceof ASTNumeric)
				constantValue = Integer.parseInt((String) this.jjtGetChild(1).value);

			// if(constantValue != null){
				Map<String, Integer> rhs = variables.get(name);
				rhs = rhs != null ? rhs : new HashMap<String, Integer>();
				rhs.put(index, constantValue);
				variables.put(name, rhs);
			// }
		}
		// Clean previously assigned indexes
		else{
			Map<String, Integer> rhs = variables.get(name);
			if(rhs == null)
				return;
			Integer length = rhs.get("#");
			variables.remove(name);
			// if(length != null){
				rhs = new HashMap<String, Integer>();
				rhs.put("#", length);
				variables.put(name, rhs);
			// }
		}
	}


	public Integer getArraySize(){
		SimpleNode simpleNode = this.jjtGetChild(1);
		if(!(simpleNode instanceof ASTNew))
			return null;
		SimpleNode simpleNode2 = simpleNode.jjtGetChild(0);
		String type = (String) simpleNode2.jjtGetValue();
		if(!type.equals("int[]"))
			return null;
		SimpleNode simpleNode3 = simpleNode2.jjtGetChild(0);
		if(!(simpleNode3 instanceof ASTNumeric))
			return null;
		return Integer.parseInt((String) simpleNode3.value);
	}

	public void generateCode(Descriptor descriptor) {

		SimpleNode lhsNode = this.jjtGetChild(0);
		SimpleNode rhsNode = this.jjtGetChild(1);

		MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
		VariableDescriptor lhs = null;


		// If left side is an array access the stack needs to be:
		// arrayRef, index, value ->
		if(!(lhsNode instanceof ASTIdentifier)){
			// arrayRef
			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetChild(0).jjtGetValue());

			if(lhs.getVisibility() == Visibility.PUBLIC)
				parser.addInstruction(new JVMInstruction("aload_0",1));

			parser.addInstruction(JVMHelper.getLoadInstruction(lhs));

			// index
			lhsNode.jjtGetChild(1).generateCode(descriptor);
		}

		else {
			String variableName = (String) lhsNode.jjtGetValue();
			lhs = methodDescriptor.searchVariable(variableName);

			if (this.parser.performOptimizationO() && ! lhs.usedAssignment(this.assignmentID) && lhs.getVisibility() != Visibility.PUBLIC && ! rhsNode.hasMethodCallInside()) {
				return;
			}

			if (lhs.getVisibility() == Visibility.PUBLIC)
				parser.addInstruction(new JVMInstruction("aload_0",1));
			// inc
			else if(rhsNode instanceof ASTAdd || rhsNode instanceof ASTSub){
				if(generateInc(lhs, rhsNode, methodDescriptor))
					return;
			}
		}

		// value
		rhsNode.generateCode(descriptor);

		// store instruction
		if (lhsNode instanceof ASTIdentifier){
			parser.addInstruction(JVMHelper.getStoreInstruction(lhs));
		}
		else{
			parser.addInstruction(JVMHelper.getArrayStoreInstruction(lhs));
		}
	}

	private boolean generateInc(VariableDescriptor var, SimpleNode expr, MethodDescriptor methodDescriptor) {
		SimpleNode lhsNode = expr.jjtGetChild(0);
		SimpleNode rhsNode = expr.jjtGetChild(1);
		// lhs -> Identifier; rhs -> Numeric
		if(lhsNode instanceof ASTIdentifier && rhsNode instanceof ASTNumeric){
			VariableDescriptor var2 = methodDescriptor.searchVariable((String) lhsNode.jjtGetValue());
			if(!var.getIdentifier().equals(var2.getIdentifier()))
				return false;
			int inc = (expr instanceof ASTAdd) ? Integer.parseInt((String) rhsNode.jjtGetValue()) : - Integer.parseInt((String) rhsNode.jjtGetValue());

			parser.addInstruction(JVMHelper.getIncInstruction(var, inc));
			return true;
		}

		// lhs -> Numeric; rhs -> Identifier
		if(lhsNode instanceof ASTNumeric && rhsNode instanceof ASTIdentifier){
			if(expr instanceof ASTSub)
				return false;
			VariableDescriptor var2 = methodDescriptor.searchVariable((String) rhsNode.jjtGetValue());
			if(!var.getIdentifier().equals(var2.getIdentifier()))
				return false;

			int inc = Integer.parseInt((String) lhsNode.jjtGetValue());

			parser.addInstruction(JVMHelper.getIncInstruction(var, inc));
			return true;
		}

		return false;
	}

	@Override
	public String toString() {
		return ParserTreeConstants.jjtNodeName[id] + "#" + this.assignmentID;
	}

	public void generateCFG(List<BitSet> use, List<BitSet> def, List<BitSet> succ, MethodDescriptor mDescriptor) {
		BitSet useNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet defNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet succNode = new BitSet();

		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			// if position 0, variable is being defined
			boolean varDef = (i == 0);
			this.jjtGetChild(i).generateCFGNode(useNode, defNode, varDef, mDescriptor);
		}

		use.add(useNode);
		def.add(defNode);
		succ.add(succNode);
		succNode.set(succ.size());
		// if (succ.size() > 1)
		// 	succ.get(succ.size() - 2).set(succ.size() - 1);
	}
}
/*
 * JavaCC - OriginalChecksum=b5ad1cee5ac10f7e7cd18d830ac9c91d (do not edit this
 * line)
 */
