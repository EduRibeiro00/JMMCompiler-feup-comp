import exceptions.SemanticParseException;
import java.util.Set;
import java.util.Map;
import java.util.BitSet;
import enums.Visibility;

/* Generated By:JJTree: Do not edit this line. ASTArrayAccess.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTArrayAccess extends SimpleNode {
    public ASTArrayAccess(int id) {
        super(id);
    }

    public ASTArrayAccess(Parser p, int id) {
        super(p, id);
    }

    @Override
	public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException{
        MethodDescriptor functionST = (MethodDescriptor) descriptor;

        SimpleNode arrayNode = this.jjtGetChild(0);

        String arrayType = arrayNode.analyze(functionST, variables);
        String expressionType = this.jjtGetChild(1).analyze(functionST, variables);

        if(!arrayType.equals("int[]") && !arrayType.equals("String[]") ){

            this.parser.handleSemanticError(new SemanticParseException("Array type is not supported (" + arrayType + ")"), this);
            this.returnType = arrayType;
            return arrayType.substring(0,arrayType.length() - 2);
        }

        if(!expressionType.equals("int"))
            this.parser.handleSemanticError(new SemanticParseException("Expression to access array does not equate to an int (" + expressionType + ")"), this);

        this.returnType = arrayType;
        return arrayType.substring(0,arrayType.length() - 2);
    }

    public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
        super.optimize(descriptor, variables);
		if(this.jjtGetChild(1) instanceof ASTNumeric && this.jjtGetChild(0) instanceof ASTIdentifier){
            String name = (String) this.jjtGetChild(0).jjtGetValue();
            String index = (String) this.jjtGetChild(1).jjtGetValue();

            Map<String, Integer> rhs = variables.get(name);
            if(rhs == null)
                return;
            Integer constValue = rhs.get(index);
            if((this.jjtGetParent() instanceof ASTAssignment) && this.jjtGetParent().jjtGetChild(0) == this)
                return;
            if (constValue != null){
                SimpleNode constNode = new ASTNumeric(this.parser, ParserTreeConstants.JJTNUMERIC);
                constNode.value = Integer.toString(constValue);
                if(variables.get("#cond#") == null && constNode != null)
                    ((SimpleNode) this.jjtGetParent()).replaceChild(this, constNode);
                else{
                    this.calcValue = constValue;
                }
            }
		}
    }

    @Override
    public void generateCode(Descriptor descriptor){

        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

        SimpleNode arrayNode = this.jjtGetChild(0);
        VariableDescriptor se = methodDescriptor.searchVariable((String) arrayNode.jjtGetValue());

        // arrayRef, index ->

        // arrayRef

        if(se != null){
            if(se.getVisibility() == Visibility.PUBLIC)
    			parser.addInstruction(new JVMInstruction("aload_0",1));
            parser.addInstruction(JVMHelper.getLoadInstruction(se));
        }

		// index
		this.jjtGetChild(1).generateCode(descriptor);

        if(se != null)
		    parser.addInstruction(JVMHelper.getArrayLoadInstruction(se));
        else
            parser.addInstruction(JVMHelper.getArrayLoadInstruction(arrayNode.getReturnType()));
    }

    @Override
    public void generateCFGNode(BitSet useNode, BitSet defNode, boolean varDef, MethodDescriptor mDescriptor) {
        for (int i = 0; i < this.jjtGetNumChildren(); i++) {
            this.jjtGetChild(i).generateCFGNode(useNode, defNode, false, mDescriptor);
        }
    }
}
/*
 * JavaCC - OriginalChecksum=07823d6065ca9b37f085148b14d167b9 (do not edit this
 * line)
 */
