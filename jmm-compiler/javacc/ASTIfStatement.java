import exceptions.SemanticParseException;

import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import enums.ConditionType;
import java.util.List;
import java.util.BitSet;

/* Generated By:JJTree: Do not edit this line. ASTIfStatement.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTIfStatement extends SimpleNode {
    private ConditionType type = ConditionType.Undefined;
    public ASTIfStatement(int id) {
        super(id);
    }

    public ASTIfStatement(Parser p, int id) {
        super(p, id);
    }

    @Override
    public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException {
        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

        try {
            this.jjtGetChild(0).analyze(descriptor, variables);
        } catch (SemanticParseException ex) {

        }

        Set<String> cloned1 = new HashSet<String>(variables);
        try {
            this.jjtGetChild(1).analyze(descriptor, cloned1);
        } catch (SemanticParseException ex) {

        }

        Set<String> cloned2 = new HashSet<String>(variables);
        try {
            this.jjtGetChild(2).analyze(descriptor, cloned2);
        } catch (SemanticParseException ex) {

        }


        for(String variable : cloned1)
            methodDescriptor.searchVariable(variable).setProgression();
        for(String variable : cloned2)
            methodDescriptor.searchVariable(variable).setProgression();

        cloned1.retainAll(cloned2);

        variables.addAll(cloned1);


        return "";
    }

    public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
        this.jjtGetChild(0).optimize(descriptor, variables);

        if(this.jjtGetChild(0).getCalcValue() != null && this.jjtGetChild(0).getCalcValue() == 1)
            this.type = ConditionType.True;
        else if(this.jjtGetChild(0).getCalcValue() != null && this.jjtGetChild(0).getCalcValue() == 0){
            this.type = ConditionType.False;
        }

        Map<String, Set<Integer>> assignmentsBeforeIf = new HashMap<>();
        Map<String, Set<Integer>> assignmentsBeforeElse = new HashMap<>();
        if (ConditionType.Undefined == this.type) {
            for (String variable : variables.keySet()) {
                // if(variables.get(variable).get("#") == null)
                //     continue;
                VariableDescriptor varDesc = methodDescriptor.getVariable(variable);
                if (varDesc != null) {
                    Set<Integer> assignments = varDesc.getAssignmentsForNextUsage();
                    assignmentsBeforeIf.put(variable, assignments);
                }
            }
        }

        Map<String, Map<String, Integer>> cloned1 = null;
        Map<String, Map<String, Integer>> cloned2 = null;
        if(ConditionType.True == this.type || ConditionType.Undefined == this.type){
            // Cloning map
            cloned1 = new HashMap<String, Map<String, Integer>>();
            for (Map.Entry<String, Map<String, Integer>> entry : variables.entrySet()) {
                cloned1.put(entry.getKey(),  (Map<String, Integer>) ((HashMap<String, Integer>) variables.get(entry.getKey())).clone());
            }
            this.jjtGetChild(1).optimize(descriptor, cloned1);

            if (ConditionType.Undefined == this.type) {
                for (String variable : cloned1.keySet()) {
                    VariableDescriptor varDesc = methodDescriptor.getVariable(variable);
                    if (varDesc != null) {
                        assignmentsBeforeElse.put(variable, varDesc.getAssignmentsForNextUsage());
                        Set<Integer> assignments = assignmentsBeforeIf.get(variable);
                        varDesc.resetAssignmentsForNextUsage();
                        if (assignments != null) {
                            varDesc.addAssignmentsForNextUsage(assignments);
                        }
                    }
                }
            }
        }

        if(ConditionType.False == this.type || ConditionType.Undefined == this.type){
            // Cloning map
            cloned2 = new HashMap<String, Map<String, Integer>>();
            for (Map.Entry<String, Map<String, Integer>> entry : variables.entrySet()) {
                cloned2.put(entry.getKey(),  (Map<String, Integer>) ((HashMap<String, Integer>) variables.get(entry.getKey())).clone());
            }
            this.jjtGetChild(2).optimize(descriptor, cloned2);
        }


        if(ConditionType.Undefined == this.type){
            for(String entry : cloned2.keySet()){
                if(cloned1.get(entry) == null){
                    Map<String, Integer> prov = new HashMap<String, Integer>();
                    prov.put("#", null);
                    cloned1.put(entry, prov);
                }
                else if(cloned2.get(entry) != null)
                    for(String id : cloned2.get(entry).keySet())
                        cloned1.get(entry).putIfAbsent(id, null);
            }



            for (String name : cloned1.keySet()) {
                Map<String, Integer> mapIf = cloned1.get(name);
                Map<String, Integer> mapElse = cloned2.get(name) != null ? cloned2.get(name) : new HashMap<String, Integer>();

                for(String id : mapIf.keySet()){
                    Integer valueIf = mapIf.get(id);
                    Integer valueElse = mapElse.get(id);

                    Integer value = null;
                    if (valueIf != null && valueElse != null && valueIf == valueElse) {
                        value = valueIf;
                    }

                    mapIf.put(id, value);
                }
                cloned1.put(name, mapIf);
            }

            // Deal with assignments made before the If statement that may become "used"
            for (String var : assignmentsBeforeElse.keySet()) {
                // if(variables.get(var).get("#") == null)
                //     continue;
                VariableDescriptor varDesc = methodDescriptor.getVariable(var);
                if (varDesc == null)
                    continue;

                Set<Integer> assignmentsNeeded = assignmentsBeforeElse.get(var);

                varDesc.addAssignmentsForNextUsage(assignmentsNeeded);
            }
        }
        else if(ConditionType.False == this.type){
            cloned1 = new HashMap<String, Map<String, Integer>>();
            for (Map.Entry<String, Map<String, Integer>> entry : cloned2.entrySet()) {
                cloned1.put(entry.getKey(),  (Map<String, Integer>) ((HashMap<String, Integer>) cloned2.get(entry.getKey())).clone());
            }
        }


        for(Map.Entry<String, Map<String, Integer>> entry : cloned1.entrySet()){
            String name = entry.getKey();
            if(variables.get(name) == null)
                variables.put(name, entry.getValue());
            else{
                for(Map.Entry<String, Integer> entry2 : entry.getValue().entrySet())
                    variables.get(name).put(entry2.getKey(), entry2.getValue());
            }
        }
    }

    @Override
    public void generateCode(Descriptor descriptor) {
        int ifNumber = -1;
        if(ConditionType.Undefined == this.type)
            ifNumber = JVMHelper.getIfLabel();

        // Generate Condition
        if(ConditionType.Undefined == this.type){
            if(this.jjtGetChild(0).jjtGetChild(0) instanceof ASTLess)
                this.generateLessCondition(descriptor, ifNumber);
            else{
                this.jjtGetChild(0).generateCode(descriptor);
                parser.addInstruction(new JVMInstruction("ifeq ELSE_" + ifNumber,-1));
            }
        }

        // Generate If
        if(ConditionType.Undefined == this.type || ConditionType.True == this.type){
            this.jjtGetChild(1).generateCode(descriptor);
            if(!(this.jjtGetChild(1) instanceof ASTScope)){

                // Add a pop to avoid leaving "stray" elements on the stack
                if(! (this.jjtGetChild(1) instanceof ASTVarDeclaration)){

                    if(this.jjtGetChild(1) .getReturnType() != null && this.jjtGetChild(1).getReturnType() != "void" )
                        parser.addInstruction(new JVMInstruction("pop",-1));
			    }
            }
            if(ConditionType.Undefined == this.type){
                parser.addInstruction(new JVMInstruction("goto END_IF_ELSE_" + ifNumber,0));
                parser.addInstruction(new JVMInstruction("ELSE_" + ifNumber + ":",0));
            }
        }

        // Generate Else
        if(ConditionType.Undefined == this.type || ConditionType.False == this.type){
            this.jjtGetChild(2).generateCode(descriptor);
            if(!(this.jjtGetChild(2) instanceof ASTScope)){

                // Add a pop to avoid leaving "stray" elements on the stack
                if(! (this.jjtGetChild(2) instanceof ASTVarDeclaration)){

                    if(this.jjtGetChild(2) .getReturnType() != null && this.jjtGetChild(2).getReturnType() != "void" )
                        parser.addInstruction(new JVMInstruction("pop",-1));
                }
            }
            if(ConditionType.Undefined == this.type)
                parser.addInstruction(new JVMInstruction("END_IF_ELSE_" + ifNumber + ":",0));
        }
    }

	public void generateLessCondition(Descriptor descriptor, int ifLabel) {
        SimpleNode astLess = this.jjtGetChild(0).jjtGetChild(0);

		SimpleNode lhsNode = astLess.jjtGetChild(0);
        SimpleNode rhsNode = astLess.jjtGetChild(1);

        if(lhsNode instanceof ASTNumeric && Integer.parseInt((String) lhsNode.jjtGetValue()) == 0){
            // 0 < x <=> x > 0 -> x =< 0
            rhsNode.generateCode(descriptor);
            parser.addInstruction(new JVMInstruction("ifle ELSE_" + ifLabel,-1));
        }
        else if(rhsNode instanceof ASTNumeric && Integer.parseInt((String) rhsNode.jjtGetValue()) == 0){
            // x < 0 -> x >= 0
            lhsNode.generateCode(descriptor);
            parser.addInstruction(new JVMInstruction("ifge ELSE_" + ifLabel,-1));
        }
        else{
            //e < D -> esquerda >= direita
            lhsNode.generateCode(descriptor);
            rhsNode.generateCode(descriptor);

            parser.addInstruction(new JVMInstruction("if_icmpge ELSE_" + ifLabel,-2));
        }

    }

    @Override
    public void generateCFG(List<BitSet> use, List<BitSet> def, List<BitSet> succ, MethodDescriptor mDescriptor) {

        // Generate condition
        ASTCondition cond = (ASTCondition) this.jjtGetChild(0);
        cond.generateCFG(use, def, succ, mDescriptor);
        int condNodeID = succ.size() - 1;

        // Generate if
        this.jjtGetChild(1).generateCFG(use, def, succ, mDescriptor);
        succ.get(condNodeID).set(succ.size());
        int ifEndNodeID = succ.size() - 1; // Store id of the last instruction of the if

        // Generate else
        this.jjtGetChild(2).generateCFG(use, def, succ, mDescriptor);
        int elseEndNodeID = succ.size() - 1; // Store id of the last instruction of the else

        // Make the last instruction of the if point to after the else
        succ.get(ifEndNodeID).clear();
        succ.get(ifEndNodeID).set(elseEndNodeID + 1);

        // Add dummy instruction after the else
        BitSet useBoot = new BitSet(mDescriptor.getLocalsCount());
		BitSet defBoot = new BitSet(mDescriptor.getLocalsCount());
        BitSet succBoot = new BitSet();
        use.add(useBoot);
		def.add(defBoot);
        succ.add(succBoot);

        // Make dummy instruction point forward
        succBoot.set(succ.size());

        // Make last else instruction point forward
        succ.get(elseEndNodeID).clear();
        succ.get(elseEndNodeID).set(elseEndNodeID + 1);

    }
}
/*
 * JavaCC - OriginalChecksum=c5401068449a6245fa8125a53993f1d7 (do not edit this
 * line)
 */
