import java.util.List;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;

import exceptions.*;

import java.util.ArrayList;

/* Generated By:JJTree: Do not edit this line. ASTMethodCall.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */

public class ASTMethodCall extends SimpleNode {
    private MethodDescriptor calledMethodDescriptor;

    public ASTMethodCall(int id) {
        super(id);
    }

    public ASTMethodCall(Parser p, int id) {
        super(p, id);
    }

    @Override
    public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException {
        SimpleNode calledObject = this.jjtGetChild(0);
        SimpleNode calledMethod = this.jjtGetChild(1);
        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
        String calledObjectType;
        boolean mustBeStatic = false;

        try {
            // Check if left size is an identifier (class name or variable) or an expression
            if (calledObject instanceof ASTIdentifier) {
                calledObjectType = ((ASTIdentifier) calledObject).analyze(descriptor, variables, true);
            } else {
                calledObjectType = calledObject.analyze(descriptor, variables);
            }
        } catch (VariableUndefinedException ex) {
            calledObjectType = (String) calledObject.value;
            mustBeStatic = true;
        }

        if (calledObjectType.equals("boolean") || calledObjectType.equals("int")) {
            this.parser.handleSemanticError(
                    new SemanticParseException("A method can't be called on " + calledObjectType), this);
            this.returnType = calledObjectType;

            return this.returnType;
        }

        String methodName = (String) calledMethod.jjtGetValue();
        if (methodName.equals("length")) {
            if (! calledObjectType.endsWith("[]")) {
                this.parser.handleSemanticError(
                    new SemanticParseException("Object of type " + calledObjectType + " doesn't have length property."), this);
            }

            this.returnType = "int";
            return "int";
        }

        this.returnType = this.checkMethodOverloads(calledObjectType, methodDescriptor, calledMethod, mustBeStatic, variables);
        return this.returnType;
    }

    @Override
    public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables){
        SimpleNode calledObject = this.jjtGetChild(0);
        SimpleNode calledMethod = this.jjtGetChild(1);
        String methodName = (String) calledMethod.jjtGetValue();

        if(methodName.equals("length") && calledObject instanceof ASTIdentifier){
            String objectName = (String) calledObject.jjtGetValue();
            Map<String, Integer> name = variables.get(objectName);
            if(name == null)
                return;
            Integer length = name.get("#");
            if(length != null){
                SimpleNode constNode = new ASTNumeric(this.parser, ParserTreeConstants.JJTNUMERIC);
                constNode.value = Integer.toString(length);
                if(variables.get("#cond#") == null){
                    ((SimpleNode) this.jjtGetParent()).replaceChild(this, constNode);
                }
                else
                    this.calcValue = length;
            } else {
                if (variables.get("#cond#") == null) {
                    MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
                    if (methodDescriptor != null) {
                        VariableDescriptor variableDescriptor = methodDescriptor.getVariable(objectName);
                        if (variableDescriptor != null) {
                            variableDescriptor.assignmentUsage();
                        }
                    }
                }
            }
            return;
        }
        calledObject.optimize(descriptor, variables);
        calledMethod.optimize(descriptor, variables);
        this.checkArrayArg(descriptor, variables);
    }

    public void checkArrayArg(Descriptor descriptor, Map<String, Map<String, Integer>> variables){
        MethodDescriptor functionST = (MethodDescriptor) descriptor;
        if (this.jjtGetChild(1).jjtGetNumChildren() != 0) {
            for (SimpleNode child : this.jjtGetChild(1).children) {
                if(child instanceof ASTIdentifier){
                    String childName = (String) child.jjtGetValue();
                    VariableDescriptor childVE = functionST.getVariable(childName);
                    // Global
                    if(childVE == null)
                        continue;

                    if(childVE.getType().equals("int[]")){
                        if(variables.get(childName) == null){
                            Map<String, Integer> prov = new HashMap<String, Integer>();
                            prov.put("#", null);
                            variables.put(childName, prov);
                        }
                        else
                            for(String id : variables.get(childName).keySet())
                                variables.get(childName).put(id, null);

                    }
                }
            }
        }
    }


    public String checkMethodOverloads(String calledClass, MethodDescriptor methodDescriptor, SimpleNode calledMethod,
            boolean mustBeStatic, Set<String> variables) throws SemanticParseException {

        GeneralDescriptor generalDescriptor = methodDescriptor.getParentClass().getGeneralDescriptor();
        String calledMethodName = (String) calledMethod.value;
        HashMap<String, MethodDescriptor> availableOverloads = null;

        // Get available overloard for method
        try{
            availableOverloads  = generalDescriptor.getMethodOverloads(calledClass, calledMethodName);
        }
        catch(UnknownClassException ex){

            this.parser.handleSemanticError(ex, this.jjtGetChild(0));
            throw ex;
        }

        // Check if any method overload corresponds to the given arguments
        List<String> argTypes = new ArrayList<>();
        if (calledMethod.jjtGetNumChildren() != 0) {
            for (SimpleNode child : calledMethod.children) {
                argTypes.add((String) child.analyze(methodDescriptor, variables));
            }
        }

        StringBuilder argsSB = new StringBuilder("(");
        boolean first = true;
        for (String arg : argTypes) {
            if (!first) {
                argsSB.append(",");
            }
            argsSB.append(arg);
            first = false;
        }
        argsSB.append(")");

        // Method exists but the needed overload doesn't
        if (availableOverloads != null && !availableOverloads.containsKey(argsSB.toString())) {
            String msg = "Method " + calledMethodName + " has no overload with arguments " + argsSB.toString()
                    + ". Available are: ";

            if(availableOverloads.keySet().size() > 0){
                for (String ol : availableOverloads.keySet()) {
                    msg += " "+ ol;
                }
            }
            else {
                msg += " None";
            }


            UnknownOverloadException ex = new UnknownOverloadException(msg);
            this.parser.handleSemanticError(ex, this);
            throw ex;

        }
        // The needed overload exists but is not static (has it should be)
        else if (mustBeStatic && ! availableOverloads.get(argsSB.toString()).isStatic()) {
            this.parser.handleSemanticError(new SemanticParseException("Method " + calledMethodName + argsSB.toString() + " is not a static method"), this);
        }

        this.calledMethodDescriptor = availableOverloads.get(argsSB.toString());
        return calledMethodDescriptor.getReturn().getType();
    }

    @Override
    public void generateCode(Descriptor descriptor) {
        SimpleNode calledMethodNode = this.jjtGetChild(1);
        boolean isLengthCall = ((String) calledMethodNode.jjtGetValue()).equals("length");

        if (this.calledMethodDescriptor == null && !isLengthCall) {
            System.out.println("CALLED METHOD DESCRIPTOR IS NULL " + (String) calledMethodNode.jjtGetValue());
            return;
        }

        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

        if (isLengthCall || !calledMethodDescriptor.isStatic()) {
            SimpleNode calledObject = this.jjtGetChild(0);
            calledObject.generateCode(methodDescriptor);
        }

        if (isLengthCall) {
            parser.addInstruction(new JVMInstruction("arraylength",0));
            return;
        }

        for (int i = 0; i < calledMethodNode.jjtGetNumChildren(); i++)
            calledMethodNode.jjtGetChild(i).generateCode(methodDescriptor);

        parser.addInstruction(JVMHelper.getMethodInvocation(methodDescriptor, this.calledMethodDescriptor));

    }

    public boolean hasMethodCallInside() {
        return true;
    }
}
/*
 * JavaCC - OriginalChecksum=c431bc197d60321c47680450a6c0622a (do not edit this
 * line)
 */
