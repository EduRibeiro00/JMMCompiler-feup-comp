import exceptions.SemanticParseException;
import java.util.Set;
import java.util.Map;

/* Generated By:JJTree: Do not edit this line. ASTLess.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTLess extends SimpleNode {
    public ASTLess(int id) {
        super(id);
		this.returnType = "boolean";
    }

    public ASTLess(Parser p, int id) {
        super(p, id);
		this.returnType = "boolean";
    }

    @Override
	public String analyze(Descriptor descriptor, Set<String> variables) throws SemanticParseException{
		MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

		SimpleNode lhsNode = this.jjtGetChild(0);
		SimpleNode rhsNode = this.jjtGetChild(1);

		String lhsType = lhsNode.analyze(methodDescriptor, variables);
		String rhsType = rhsNode.analyze(methodDescriptor, variables);

		if ( !lhsType.equals("int") || !rhsType.equals("int"))
			this.parser.handleSemanticError(new SemanticParseException("Wrong types in less operation: " + lhsNode.jjtGetValue() + "[" + lhsType + "]" + " and " + rhsNode.jjtGetValue() + "[" + rhsType + "]"), this);

		return this.returnType;
	}

	public void optimize(Descriptor descriptor, Map<String, Map<String, Integer>> variables) {
		SimpleNode lhsNode = this.jjtGetChild(0);
		SimpleNode rhsNode = this.jjtGetChild(1);

		lhsNode.optimize(descriptor, variables);
		rhsNode.optimize(descriptor, variables);

		// If both childs are numeric substitute this node with its result
		if (this.jjtGetChild(0) instanceof ASTNumeric && this.jjtGetChild(1) instanceof ASTNumeric) {
			Integer leftOperand = Integer.parseInt((String) this.jjtGetChild(0).value);
			Integer rightOperand = Integer.parseInt((String) this.jjtGetChild(1).value);

			ASTBoolean constNode = new ASTBoolean(this.parser, ParserTreeConstants.JJTBOOLEAN);
			if (leftOperand < rightOperand) {
				constNode.value = "true";
			} else {
				constNode.value = "false";
			}

			((SimpleNode) this.jjtGetParent()).replaceChild(this, constNode);
			return;
		}

		// Other wise, if we shouldn't simplify (p.e. in 1st phase of conditions) set calcValue with the calculated value
		Integer leftOperand = this.jjtGetChild(0).getCalcValue();
		Integer rightOperand = this.jjtGetChild(1).getCalcValue();
		if(leftOperand == null && this.jjtGetChild(0) instanceof ASTNumeric)
			leftOperand = Integer.parseInt((String) this.jjtGetChild(0).value);
		else if(rightOperand == null && this.jjtGetChild(1) instanceof ASTNumeric)
			rightOperand = Integer.parseInt((String) this.jjtGetChild(1).value);
		if(variables.get("#cond#") != null && leftOperand != null && rightOperand != null){
			this.calcValue = leftOperand < rightOperand ? 1 : 0;		
		}
	}

	@Override
	public void generateCode(Descriptor descriptor) {

		SimpleNode lhsNode = this.jjtGetChild(0);
		SimpleNode rhsNode = this.jjtGetChild(1);

		String label1 = JVMHelper.getLabel();
		String label2 = JVMHelper.getLabel();

		if(this.jjtGetChild(0) instanceof ASTNumeric && Integer.parseInt((String) lhsNode.jjtGetValue()) == 0){
            // 0 < x <=> x > 0 -> x =< 0
            rhsNode.generateCode(descriptor);
            parser.addInstruction(new JVMInstruction("ifle " + label1,-1));
        }
        else if(rhsNode instanceof ASTNumeric && Integer.parseInt((String) rhsNode.jjtGetValue()) == 0){
            // x < 0 -> x >= 0
            lhsNode.generateCode(descriptor);
            parser.addInstruction(new JVMInstruction("ifge " + label1,-1));
        }
        else{
			lhsNode.generateCode(descriptor);
			rhsNode.generateCode(descriptor);
            //e < D -> esquerda >= direita
			parser.addInstruction(new JVMInstruction("if_icmpge " + label1,-2));
		}

		parser.addInstruction(new JVMInstruction("iconst_1",1));
		// -1 because only one side will run
		parser.addInstruction(new JVMInstruction("goto " + label2,-1));
		parser.addInstruction(new JVMInstruction(label1 + ":\niconst_0",1));
		parser.addInstruction(new JVMInstruction(label2 + ":",0));
	}
}
/*
 * JavaCC - OriginalChecksum=e369deba5f17e20087155e1e01e4f628 (do not edit this
 * line)
 */
