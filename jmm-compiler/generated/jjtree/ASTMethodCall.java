import java.util.List;
import java.util.HashSet; 
import java.util.HashMap; 

import exceptions.*;

import java.util.ArrayList;

/* Generated By:JJTree: Do not edit this line. ASTMethodCall.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */

public class ASTMethodCall extends SimpleNode {
    private MethodDescriptor calledMethodDescriptor;

    public ASTMethodCall(int id) {
        super(id);
    }

    public ASTMethodCall(Parser p, int id) {
        super(p, id);
    }

    @Override
    public String analyze(Descriptor descriptor, HashSet<String> variables) throws SemanticParseException {
        SimpleNode calledObject = this.jjtGetChild(0);
        SimpleNode calledMethod = this.jjtGetChild(1);
        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
        String calledObjectType;
        boolean mustBeStatic = false;

        try {
            // Check if left size is an identifier (class name or variable) or an expression
            if (calledObject instanceof ASTIdentifier) {
                calledObjectType = ((ASTIdentifier) calledObject).analyze(descriptor, variables, true);
            } else {
                calledObjectType = calledObject.analyze(descriptor, variables);
            }
        } catch (VariableUndefinedException ex) {
            calledObjectType = (String) calledObject.value;
            mustBeStatic = true;
        }

        if (calledObjectType.equals("boolean") || calledObjectType.equals("int")) {
            this.parser.handleSemanticError(
                    new SemanticParseException("A method can't be called on " + calledObjectType), this);
            this.returnType = calledObjectType;

            return this.returnType;
        }

        String methodName = (String) calledMethod.jjtGetValue();
        if (methodName.equals("length")) {
            if (! calledObjectType.endsWith("[]")) {
                this.parser.handleSemanticError(
                    new SemanticParseException("Object of type " + calledObjectType + " doesn't have length property."), this);
            }

            this.returnType = "int";
            return "int";
        }

        this.returnType = this.checkMethodOverloads(calledObjectType, methodDescriptor, calledMethod, mustBeStatic, variables);
        return this.returnType;
    };

    public String checkMethodOverloads(String calledClass, MethodDescriptor methodDescriptor, SimpleNode calledMethod,
            boolean mustBeStatic, HashSet<String> variables) throws SemanticParseException {

        GeneralDescriptor generalDescriptor = methodDescriptor.getParentClass().getGeneralDescriptor();
        String calledMethodName = (String) calledMethod.value;
        HashMap<String, MethodDescriptor> availableOverloads = null;

        // Get available overloard for method
        try{
            availableOverloads  = generalDescriptor.getMethodOverloads(calledClass, calledMethodName);
        }
        catch(UnknownClassException ex){

            this.parser.handleSemanticError(ex, this.jjtGetChild(0));
            throw ex;
        }

        // Check if any method overload corresponds to the given arguments
        List<String> argTypes = new ArrayList<>();
        if (calledMethod.jjtGetNumChildren() != 0) {
            for (SimpleNode child : calledMethod.children) {
                argTypes.add((String) child.analyze(methodDescriptor, variables));
            }
        }

        StringBuilder argsSB = new StringBuilder("(");
        boolean first = true;
        for (String arg : argTypes) {
            if (!first) {
                argsSB.append(",");
            }
            argsSB.append(arg);
            first = false;
        }
        argsSB.append(")");

        // Method exists but the needed overload doesn't
        if (availableOverloads != null && !availableOverloads.containsKey(argsSB.toString())) {
            String msg = "Method " + calledMethodName + " has no overload with arguments " + argsSB.toString()
                    + ". Available are: ";

            if(availableOverloads.keySet().size() > 0){
                for (String ol : availableOverloads.keySet()) {
                    msg += " "+ ol;
                }
            }
            else {
                msg += " None";
            }


            UnknownOverloadException ex = new UnknownOverloadException(msg);
            this.parser.handleSemanticError(ex, this);
            throw ex;

        } 
        // The needed overload exists but is not static (has it should be)
        else if (mustBeStatic && ! availableOverloads.get(argsSB.toString()).isStatic()) {
            this.parser.handleSemanticError(new SemanticParseException("Method " + calledMethodName + argsSB.toString() + " is not a static method"), this);
        }

        this.calledMethodDescriptor = availableOverloads.get(argsSB.toString());
        return calledMethodDescriptor.getReturn().getType();
    }

    @Override
    public void generateCode(Descriptor descriptor) {
        SimpleNode calledMethodNode = this.jjtGetChild(1);
        boolean isLengthCall = ((String) calledMethodNode.jjtGetValue()).equals("length");

        if (this.calledMethodDescriptor == null && !isLengthCall)
            return;

        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

        if (isLengthCall || !calledMethodDescriptor.isStatic()) {
            SimpleNode calledObject = this.jjtGetChild(0);
            calledObject.generateCode(methodDescriptor);
        }

        if (isLengthCall) {
            parser.addInstruction(new JVMInstruction("arraylength",0));
            return;
        }

        for (int i = 0; i < calledMethodNode.jjtGetNumChildren(); i++)
            calledMethodNode.jjtGetChild(i).generateCode(methodDescriptor);

        parser.addInstruction(JVMHelper.getMethodInvocation(methodDescriptor, this.calledMethodDescriptor));

        // if((this.parent instanceof ASTBody || this.parent instanceof ASTScope) && !this.calledMethodDescriptor.getReturn().getType().equals("void"))
        //     parser.addInstruction(new JVMInstruction("pop",-1));

    }

    
}
/*
 * JavaCC - OriginalChecksum=c431bc197d60321c47680450a6c0622a (do not edit this
 * line)
 */
