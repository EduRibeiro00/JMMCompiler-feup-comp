import exceptions.SemanticParseException;
import java.util.BitSet;
import java.util.List;

import java.util.HashSet;

import enums.Visibility; 

/* Generated By:JJTree: Do not edit this line. ASTAssignment.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTAssignment extends SimpleNode {
	public ASTAssignment(int id) {
		super(id);
	}

	public ASTAssignment(Parser p, int id) {
		super(p, id);
	}

	@Override
	public String analyze(Descriptor descriptor, HashSet<String> variables) throws SemanticParseException {
		MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

		SimpleNode lhsNode = this.jjtGetChild(0);
		VariableDescriptor lhs = null;
		String lhsType = "";

		// Left side is identifier
		if(lhsNode instanceof ASTIdentifier){

			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetValue());
			if(lhs == null){

				SemanticParseException ex = new SemanticParseException(lhsNode.jjtGetValue() + " doesn't exist");
				this.parser.handleSemanticError(ex, lhsNode);
	
				throw ex;		
			}

			lhsType = lhs.getType();

		}
		// Left side is array access 
		else{ 
			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetChild(0).jjtGetValue());
			
			if(lhs == null){

				SemanticParseException ex = new SemanticParseException(lhsNode.jjtGetChild(0).jjtGetValue() + " doesn't exist");
				this.parser.handleSemanticError(ex, lhsNode.jjtGetChild(0));
	
				throw ex;		
			}
			
			lhsType = lhsNode.analyze(methodDescriptor, variables);
		}

		SimpleNode rhsNode = this.jjtGetChild(1);
		String rhsType = rhsNode.analyze(methodDescriptor, variables);

		// Check if left side and right side types match
		if(!lhsType.equals(rhsType)){
			String extendedClassName = methodDescriptor.getparentClass().getExtendedClassName();
			if(extendedClassName == null || !extendedClassName.equals(lhsType))
				this.parser.handleSemanticError(new SemanticParseException("Assignment mismatch: " + lhsNode.jjtGetValue() + "[" + lhsType + "]" + " and " + rhsNode.jjtGetValue() + "[" + rhsType + "]"), this);
		}

		// Progression data
		// lhs.setProgression();
		variables.add(lhs.getIdentifier());
		return "";
	}

	public void generateCode(Descriptor descriptor) {

		SimpleNode lhsNode = this.jjtGetChild(0);
		SimpleNode rhsNode = this.jjtGetChild(1);
		
		MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;
		VariableDescriptor lhs = null;


		// If left side is an array access the stack needs to be:
		// arrayRef, index, value ->
		if(!(lhsNode instanceof ASTIdentifier)){
			
			// arrayRef
			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetChild(0).jjtGetValue());
			
			if(lhs.getVisibility() == Visibility.PUBLIC)
				parser.addInstruction(new JVMInstruction("aload_0",1));

			parser.addInstruction(JVMHelper.getLoadInstruction(lhs));

			// index
			lhsNode.jjtGetChild(1).generateCode(descriptor);
		}

		else {
			lhs = methodDescriptor.searchVariable((String) lhsNode.jjtGetValue());
			if(lhs.getVisibility() == Visibility.PUBLIC)
				parser.addInstruction(new JVMInstruction("aload_0",1));
			// inc
			else if(rhsNode instanceof ASTAdd || rhsNode instanceof ASTSub){
				// TODO: ver se tbm dÃ¡ para arrays
				if(generateInc(lhs, rhsNode, methodDescriptor))
					return;
			}
		}

		// value
		rhsNode.generateCode(descriptor);

		// store instruction
		if(lhsNode instanceof ASTIdentifier){
			parser.addInstruction(JVMHelper.getStoreInstruction(lhs));
		}
		else{
			parser.addInstruction(JVMHelper.getArrayStoreInstruction(lhs));
		}
	}

	private boolean generateInc(VariableDescriptor var, SimpleNode expr, MethodDescriptor methodDescriptor) {
		SimpleNode lhsNode = expr.jjtGetChild(0);
		SimpleNode rhsNode = expr.jjtGetChild(1);
		// lhs -> Identifier; rhs -> Numeric
		if(lhsNode instanceof ASTIdentifier && rhsNode instanceof ASTNumeric){
			VariableDescriptor var2 = methodDescriptor.searchVariable((String) lhsNode.jjtGetValue());
			if(!var.getIdentifier().equals(var2.getIdentifier()))
				return false;
			int inc = (expr instanceof ASTAdd) ? Integer.parseInt((String) rhsNode.jjtGetValue()) : - Integer.parseInt((String) rhsNode.jjtGetValue());
			
			parser.addInstruction(JVMHelper.getIncInstruction(var, inc));
			return true;
		}

		// lhs -> Numeric; rhs -> Identifier
		if(lhsNode instanceof ASTNumeric && rhsNode instanceof ASTIdentifier){
			if(expr instanceof ASTSub)
				return false;
			VariableDescriptor var2 = methodDescriptor.searchVariable((String) rhsNode.jjtGetValue());
			if(!var.getIdentifier().equals(var2.getIdentifier()))
				return false;

			int inc = Integer.parseInt((String) lhsNode.jjtGetValue());

			parser.addInstruction(JVMHelper.getIncInstruction(var, inc));
			return true;
		}

		return false;
	}

	public void generateCFG(List<BitSet> use, List<BitSet> def, List<BitSet> succ, MethodDescriptor mDescriptor) {
		BitSet useNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet defNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet succNode = new BitSet();

		for (int i = 0; i < this.jjtGetNumChildren(); i++) {
			// if position 0, variable is being defined
			boolean varDef = (i == 0);
			this.jjtGetChild(i).generateCFGNode(useNode, defNode, varDef, mDescriptor);
		}

		use.add(useNode);
		def.add(defNode);
		succ.add(succNode);
		succNode.set(succ.size());
		// if (succ.size() > 1)
		// 	succ.get(succ.size() - 2).set(succ.size() - 1);
	}
}
/*
 * JavaCC - OriginalChecksum=b5ad1cee5ac10f7e7cd18d830ac9c91d (do not edit this
 * line)
 */
