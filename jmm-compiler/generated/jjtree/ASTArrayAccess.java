import exceptions.SemanticParseException;

import java.util.BitSet;
import java.util.HashSet; 
import enums.Visibility;

/* Generated By:JJTree: Do not edit this line. ASTArrayAccess.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTArrayAccess extends SimpleNode {
    public ASTArrayAccess(int id) {
        super(id);
    }

    public ASTArrayAccess(Parser p, int id) {
        super(p, id);
    }

    @Override
	public String analyze(Descriptor descriptor, HashSet<String> variables) throws SemanticParseException{
        MethodDescriptor functionST = (MethodDescriptor) descriptor;

        SimpleNode arrayNode = this.jjtGetChild(0);
        VariableDescriptor se = functionST.searchVariable((String) arrayNode.jjtGetValue());

        String arrayType = arrayNode.analyze(functionST, variables);
        String expressionType = this.jjtGetChild(1).analyze(functionST, variables);

        if(!arrayType.equals("int[]") && !arrayType.equals("String[]") ){

            this.parser.handleSemanticError(new SemanticParseException("Array type is not supported (" + arrayType + ")"), this);
            this.returnType = arrayType;
            return arrayType.substring(0,arrayType.length() - 2);
        }

        if(!expressionType.equals("int"))
            this.parser.handleSemanticError(new SemanticParseException("Expression to access array does not equate to an int (" + expressionType + ")"), this);

        this.returnType = arrayType;
        return arrayType.substring(0,arrayType.length() - 2);
    }

    @Override
    public void generateCode(Descriptor descriptor){

        MethodDescriptor methodDescriptor = (MethodDescriptor) descriptor;

        SimpleNode arrayNode = this.jjtGetChild(0);
        VariableDescriptor se = methodDescriptor.searchVariable((String) arrayNode.jjtGetValue());

        // arrayRef, index ->
        
        // arrayRef

        if(se != null){
            if(se.getVisibility() == Visibility.PUBLIC)
    			parser.addInstruction(new JVMInstruction("aload_0",1));
            parser.addInstruction(JVMHelper.getLoadInstruction(se));
        }

		// index
		this.jjtGetChild(1).generateCode(descriptor);
        
        if(se != null)
		    parser.addInstruction(JVMHelper.getArrayLoadInstruction(se));
        else
            parser.addInstruction(JVMHelper.getArrayLoadInstruction(arrayNode.getReturnType()));
    }

    @Override
    public void generateCFGNode(BitSet useNode, BitSet defNode, boolean varDef, MethodDescriptor mDescriptor) {
        for (int i = 0; i < this.jjtGetNumChildren(); i++) {
            this.jjtGetChild(i).generateCFGNode(useNode, defNode, false, mDescriptor);
        }
    }
}
/*
 * JavaCC - OriginalChecksum=07823d6065ca9b37f085148b14d167b9 (do not edit this
 * line)
 */
