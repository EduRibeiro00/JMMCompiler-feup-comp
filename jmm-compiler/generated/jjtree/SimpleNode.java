import exceptions.SemanticParseException;
import java.util.HashSet; 
import java.util.List;
import java.util.BitSet;

/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 7.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class SimpleNode implements Node {

	protected SimpleNode parent;
	protected SimpleNode[] children;
	protected int id;
	protected Object value;
	protected Parser parser;
	protected Token firstToken;
	protected Token lastToken;
	protected String returnType;

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(Parser p, int i) {
		this(i);
		parser = p;
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		parent = (SimpleNode) n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new SimpleNode[i + 1];
		} else if (i >= children.length) {
			SimpleNode c[] = new SimpleNode[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = (SimpleNode) n;
	}

	public SimpleNode jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	public void jjtSetValue(Object value) {
		this.value = value;
	}

	public Object jjtGetValue() {
		return value;
	}

	public Token jjtGetFirstToken() {
		return firstToken;
	}

	public void jjtSetFirstToken(Token token) {
		this.firstToken = token;
	}

	public Token jjtGetLastToken() {
		return lastToken;
	}

	public void jjtSetLastToken(Token token) {
		this.lastToken = token;
	}

	public String getReturnType(){
		return this.returnType;
	}

	/*
	 * You can override these two methods in subclasses of SimpleNode to customize
	 * the way the node appears when the tree is dumped. If your output uses more
	 * than one line you should override toString(String), otherwise overriding
	 * toString() is probably all you need to do.
	 */

	public String toString() {
		switch (ParserTreeConstants.jjtNodeName[id]) {
			case "Type":
			case "Boolean":
			case "Identifier":
			case "Numeric":
			case "Method":
			case "Import":
			case "Class":
			case "Extends":
				return ParserTreeConstants.jjtNodeName[id] + "[" + this.value + "]";
			default:
				return ParserTreeConstants.jjtNodeName[id];
		}
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/*
	 * Override this method if you want to customize how the node dumps out its
	 * children.
	 */

	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.dump(prefix + "    ");
				}
			}
		}
	}

	public int getId() {
		return id;
	}

	public String analyze(Descriptor descriptor, HashSet<String> variables) throws SemanticParseException {
		return "";
	}

  	public void generateCode(Descriptor descriptor){
  	  	return;
	}
	  
	public void generateCFG(List<BitSet> use, List<BitSet> def, List<BitSet> succ, MethodDescriptor mDescriptor) {
		BitSet useNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet defNode = new BitSet(mDescriptor.getLocalsCount());
		BitSet succNode = new BitSet();

		for (int i = 0; i < this.jjtGetNumChildren(); i++)
			this.jjtGetChild(i).generateCFGNode(useNode, defNode, false, mDescriptor);

		use.add(useNode);
		def.add(defNode);
		succ.add(succNode);
		succNode.set(succ.size());
	}

	public void generateCFGNode(BitSet useNode, BitSet defNode, boolean varDef, MethodDescriptor mDescriptor) {
		for (int i = 0; i < this.jjtGetNumChildren(); i++)
			this.jjtGetChild(i).generateCFGNode(useNode, defNode, varDef, mDescriptor);
	}
}

/*
 * JavaCC - OriginalChecksum=15789662d930da128363c781bfbf49fb (do not edit this
 * line)
 */
