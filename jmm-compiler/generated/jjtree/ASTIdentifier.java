import java.util.HashSet;
import enums.Visibility;
import exceptions.SemanticParseException;
import exceptions.VariableUndefinedException;
import java.util.List;
import java.util.BitSet;

/* Generated By:JJTree: Do not edit this line. ASTIdentifier.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTIdentifier extends SimpleNode {
    public ASTIdentifier(int id) {
        super(id);
    }

    public ASTIdentifier(Parser p, int id) {
        super(p, id);
    }

    @Override
    public String analyze(Descriptor descriptor, HashSet<String> variables) throws SemanticParseException {
        return analyze(descriptor, variables,false);
    }

    public String analyze(Descriptor descriptor, HashSet<String> variables, boolean methodCall) throws SemanticParseException {
        MethodDescriptor functionST = (MethodDescriptor) descriptor;
        VariableDescriptor se = functionST.searchVariable((String) this.jjtGetValue());

        // Variable not found in method or class
        if (se == null) {
            VariableUndefinedException undefinedException = new VariableUndefinedException(this.jjtGetValue() + " is undefined.");

            // If we are in a methodcall we won't consider this an error because the left side might be an imported class (static invocations)
            if (methodCall)
                throw undefinedException;
            else {
                this.parser.handleSemanticError(undefinedException, this);
                throw undefinedException;
            }
        }

        // Variable initialization data
        if (!se.isInitialized() && !variables.contains(se.getIdentifier())){
            if(se.hadProgression())
                this.parser.handleSemanticError(
                        new SemanticParseException(this.jjtGetValue() + " may not have been initialized before its usage.", false), this);
            else
                this.parser.handleSemanticError(
                        new SemanticParseException(this.jjtGetValue() + " was not initialized before its usage."), this);
        }
        
        this.returnType = se.getType();
        return this.returnType;
    }

    @Override
	public void generateCode(Descriptor descriptor){

        MethodDescriptor functionST = (MethodDescriptor) descriptor;
        VariableDescriptor se = functionST.searchVariable((String) this.jjtGetValue());

        if(se.getVisibility() == Visibility.PUBLIC)
            parser.addInstruction(new JVMInstruction("aload_0",1));
		parser.addInstruction(JVMHelper.getLoadInstruction(se));
	}

    public void generateCFGNode(BitSet useNode, BitSet defNode, boolean varDef, MethodDescriptor mDescriptor) {
        String variableName = (String) this.jjtGetValue();
        VariableDescriptor vDescriptor = mDescriptor.getVariable(variableName);
        VariableDescriptor vDesc = mDescriptor.searchVariable(variableName);

        // TODO: nao mudar Use ou Def se identifier for um metodo e nao uma variavel local

        if(vDesc != null && vDesc.getVisibility() == Visibility.PUBLIC){
            useNode.set(0);
        }

        if (vDescriptor != null)
            if (varDef)
                defNode.set(vDescriptor.getLocalStackPosition());
            else
                useNode.set(vDescriptor.getLocalStackPosition());

        for (int i = 0; i < this.jjtGetNumChildren(); i++) {
            this.jjtGetChild(i).generateCFGNode(useNode, defNode, false, mDescriptor);
        }
    }
}
/*
 * JavaCC - OriginalChecksum=75abfe948da46b0c7b3a59b2cae3a666 (do not edit this
 * line)
 */
