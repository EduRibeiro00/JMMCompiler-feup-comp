import exceptions.SemanticParseException;
import exceptions.UnknownClassException;
import java.util.HashSet;

import java.util.Set;
import java.util.List;
import java.util.ArrayList;

/* Generated By:JJTree: Do not edit this line. ASTNew.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTNew extends SimpleNode {
    public ASTNew(int id) {
        super(id);
        this.jjtSetValue("new");
    }

    public ASTNew(Parser p, int id) {
        super(p, id);
        this.jjtSetValue("new");
    }

    @Override
    public String analyze(Descriptor descriptor, HashSet<String> variables) throws SemanticParseException {
        MethodDescriptor functionST = (MethodDescriptor) descriptor;

        SimpleNode node = this.jjtGetChild(0);
        String type = (String) node.jjtGetValue();
        if (type.equals("int[]")) {
            if (node.jjtGetNumChildren() != 0) {
                String intType = node.jjtGetChild(0).analyze(functionST, variables);
                if (!intType.equals("int"))
                    this.parser.handleSemanticError(new SemanticParseException("Array length is not an int"), this);

            }
        } else {
            GeneralDescriptor genDesc = functionST.getParentClass().getGeneralDescriptor();
            Set<String> availableConstructors;

            try {
                availableConstructors = genDesc.getClassConstructors(type);
            } catch (UnknownClassException ex) {

                this.parser.handleSemanticError(ex, this);
                availableConstructors = null;
            }

            // Check if any method overload corresponds to the given arguments
            List<String> argTypes = new ArrayList<>();
            if (node.jjtGetNumChildren() != 0) {
                for (SimpleNode child : node.children) {
                    argTypes.add((String) child.analyze(functionST, variables));
                }
            }

            StringBuilder argsSB = new StringBuilder("(");
            boolean first = true;
            for (String arg : argTypes) {
                if (!first) {
                    argsSB.append(",");
                }
                argsSB.append(arg);
                first = false;
            }
            argsSB.append(")");
            if (availableConstructors != null && !availableConstructors.contains(argsSB.toString())) {

                String msg = "Class " + type + " has no constructor with arguments " + argsSB.toString()
                        + ". Available are:\n";

                for (String ac : availableConstructors) {
                    msg += "    " + ac;
                }

                this.parser.handleSemanticError(new SemanticParseException(msg), this);

            }
        }

        this.returnType = type;
        return type;
    }

    @Override
    public void generateCode(Descriptor descriptor) {

        SimpleNode node = this.jjtGetChild(0);
        String type = (String) node.jjtGetValue();
        if (type.equals("int[]")) {
            node.jjtGetChild(0).generateCode(descriptor);
            parser.addInstruction(JVMHelper.getNewArrayInstruction(type.substring(0, type.length() - 2)));
        } else {

            parser.addInstruction(new JVMInstruction("new " + type,1));
            parser.addInstruction(new JVMInstruction("dup",1));

            // Check if any method overload corresponds to the given arguments
            List<String> argTypes = new ArrayList<>();
            if (node.jjtGetNumChildren() != 0) {
                for (SimpleNode child : node.children){
                    child.generateCode(descriptor);
                    argTypes.add(child.getReturnType());
                }
            }
            StringBuilder argsSB = new StringBuilder("/<init>(");
            for (String arg : argTypes){
                argsSB.append(JVMHelper.getTypeDescription(arg));
            }
            argsSB.append(")V");

            parser.addInstruction(new JVMInstruction("invokespecial " + type + argsSB.toString(),-1 -argTypes.size()));
        }
    }
}
/*
 * JavaCC - OriginalChecksum=c6d588009442d8c81f835326710afcd3 (do not edit this
 * line)
 */
