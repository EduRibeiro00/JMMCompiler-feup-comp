/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options {
    LOOKAHEAD = 1;
                 
    ERROR_REPORTING = true;
                        
                            
    STATIC = false;
}


PARSER_BEGIN(Parser)

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.File;
import java.util.HashSet;
import exceptions.SemanticParseException;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/

    private int syntatcicExceptionCount = 0;                    /* Number of errors caught during parsing */
    private String syntacticErrorMessage = "";                  /* Error message associated with caught erros (while expression) */
    private int semanticExceptionCount = 0;
    private String semanticErrorMessage = "";
    private String semanticWarningMessage = "";
    private int parenthesisCount = 0;                            /* Parenthesis count for opening and closing parenthesis (parenthesisCount > 0 => more opening parenthesis than closing and vice versa) */
    private List<String> lines = new ArrayList<String>();       /* List of lines of the file to be read */
    private List<JVMInstruction> generatedLines = new ArrayList<JVMInstruction>();
    private final static int SYNTACTIC_MAX_NUM_ERRORS = 10;     /* Maximum amount of parsing errors that are recovered */
    private final static int SEMANTIC_MAX_NUM_ERRORS = 10;     /* Maximum amount of parsing errors that are recovered */
    private SimpleNode treeRoot = null;
    private BufferedWriter outputFile = null;
    private GeneralDescriptor symbolTable = null;
    public String fileName = null;

    private int lastLabelID = 0;

    /**
     * Initialize the lines array with the lines of the file to be parsed.
     */
    public void initFile(String fileName) {
        BufferedReader reader;
        this.fileName = fileName;
        try {
            reader = new BufferedReader(new FileReader(fileName));

            String line = reader.readLine();
            while (line != null) {
                lines.add(line);
                line = reader.readLine(); // read next line
            }

            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Function used to try to recover from erros on the while expression.
     * This functions skips tokens from the input until a stable point is found.
     */
    public int skipToToken() {

        Token nextToken = getToken(1);

        do {
            // Skip tokens until the eof is found, a left bracket or the while expression is closed.
            if (nextToken == null || nextToken.kind == LBRACKET || parenthesisCount == 0)
                break;

            if (nextToken.kind == LPAR) { // Increase the scope when a '(' is found
                parenthesisCount++;
            } else if (nextToken.kind == RPAR) { // Decrease the scope when a ')' is found
                parenthesisCount--;
            }

            // Advance a token
            getNextToken();
            nextToken = getToken(1);

        } while(true);


        int numParenthesisMissing = parenthesisCount;

        // Reset the scope value
        if (parenthesisCount > 0) {
            parenthesisCount = 0;
        }

        if (nextToken.kind == RPAR) {
            getNextToken();
        }

        return numParenthesisMissing;
    }

    /**
     * Function that handles while expressions' errors. It takes the exception generated inside the while
     * expression and tries to recover the error using 'skipToToken'.
     * This funcion also builds the error message associated with the parse exception and adds it to the global
     * error message, also increasing the error count.
     */
    public void handleWhileConditionError(ParseException e) throws ParseException{

        // Beginning of the error message
        String message = "> " + Colors.RED_BOLD + "Error" + Colors.RESET + " on line " + e.currentToken.next.beginLine + " column " + e.currentToken.next.beginColumn + ":\n";

        // Expected tokens
        String expected = "";

        // Tokens associated with expressions
        String[] expectedExpressionTokens = { "new", "true", "this", "false", "(", "!", "identifier", "integer" };
        boolean expectedExpression = false;

        // Go through all expected tokens and add them to the error message;
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                if (i != 0 || j != 0)
                    expected += ", ";

                if (e.tokenImage[e.expectedTokenSequences[i][j]].equals("<IDENTIFIER>")) {
                    e.tokenImage[e.expectedTokenSequences[i][j]] = "identifier";
                } else if(e.tokenImage[e.expectedTokenSequences[i][j]].equals("<NUMERIC>")) {
                    e.tokenImage[e.expectedTokenSequences[i][j]] = "numeric";
                }

                expectedExpression = expectedExpression || Arrays.asList(expectedExpressionTokens).contains(e.tokenImage[e.expectedTokenSequences[i][j]]);

                expected += e.tokenImage[e.expectedTokenSequences[i][j]];
            }
        }

        // Error recovery
        int numParenthesisMissing = skipToToken();

        // Build found-expected segment of the error message
        if (expectedExpression)
            message += " found '" + e.currentToken.next.image + "', expected an expression (tokens " + expected + ").";
        else
            message += " found '" + e.currentToken.next.image + "', expected " + expected + ".";

        if (numParenthesisMissing > 0)
            message += "\n" + "The expression is missing the closure of " + numParenthesisMissing + " parenthesis.";


        // Add lines showing the line where the error occured and build an indicator underneath.
        // Indicator is only added if a file was read by initFile
        String indicator = "";
        String errorLine = "";

        if (!lines.isEmpty()) {

            errorLine = lines.get(e.currentToken.next.beginLine - 1);

            for(int i = 0; i < e.currentToken.next.beginColumn - 1; i++) {
                if (errorLine.charAt(i) == '\t')
                    indicator += "\t";
                else
                    indicator += " ";
            }

            indicator += Colors.GREEN + "^" + Colors.RESET;
        }

        // Add message to global error message
        this.syntacticErrorMessage += message +'\n'+ errorLine + "\n" + indicator + "\n";
        this.syntatcicExceptionCount++;

        // Check if the maximum amount of errors as been reached
        if (this.syntatcicExceptionCount >= SYNTACTIC_MAX_NUM_ERRORS) {
            throw new ParseException("Parser caught the maximum amount of errors (" + SYNTACTIC_MAX_NUM_ERRORS + " errors).");
        }
    }

    public void handleSemanticError(SemanticParseException exception, SimpleNode errorNode){

        // Beginning of the error message
        String message = "";
        if(exception.isError())
            message = "> " + Colors.RED_BOLD + "Error";
        else
            message = "> " + Colors.YELLOW_BOLD + "Warning";

        message += Colors.RESET + " on line " + errorNode.jjtGetFirstToken().beginLine + " column " + errorNode.jjtGetFirstToken().beginColumn + ":\n";
        message += exception.getMessage();
        // Add lines showing the line where the error occured and build an indicator underneath.
        // Indicator is only added if a file was read by initFile
        String indicator = "";
        String errorLine = "";

        if (!lines.isEmpty()) {

            errorLine = lines.get(errorNode.jjtGetFirstToken().beginLine  - 1);

            for(int i = 0; i < errorNode.jjtGetFirstToken().beginColumn  - 1; i++) {
                if (errorLine.charAt(i) == '\t')
                    indicator += "\t";
                else
                    indicator += " ";
            }

            indicator += Colors.GREEN + "^" + Colors.RESET;
        }

        // Add message to global error message
        if(exception.isError()){
            this.semanticErrorMessage += message +'\n'+ errorLine + "\n" + indicator + "\n";
            this.semanticExceptionCount++;
        }
        else{
            this.semanticWarningMessage += message +'\n'+ errorLine + "\n" + indicator + "\n";
        }

        // Check if the maximum amount of errors as been reached
        if (this.semanticExceptionCount >= SEMANTIC_MAX_NUM_ERRORS) {
            // throw new SemanticParseException("Parser caught the maximum amount of errors (" + SEMANTIC_MAX_NUM_ERRORS + " errors).");
        }
    }

    public void addInstruction(JVMInstruction newInstruction){

        this.generatedLines.add(newInstruction);
    }

    public void addBatchInstructions(List<JVMInstruction> newInstruction){

        this.generatedLines.addAll(newInstruction);
    }

    public boolean setCurrentStackLimit(){

        int currStackSize = 0;
        int currentMax = 0;
        int i;
        JVMInstruction stackInst = null;

        for(i = this.generatedLines.size() - 1; i >= 0; i--){
            
            JVMInstruction currentInstruction = this.generatedLines.get(i);
            
            if(currentInstruction.getInstruction().indexOf(".limit stack") != -1){
                
                stackInst = currentInstruction;
                break;
            }

        }

        if(stackInst == null)
            return false;

        for(i = i+1; i < this.generatedLines.size(); i++){
            
            JVMInstruction currentInstruction = this.generatedLines.get(i);

            
            currStackSize += currentInstruction.getStackDiff();
            currentMax = Math.max(currStackSize,currentMax);
            // System.out.println(currentInstruction.getInstruction() + " - "  + currentInstruction.getStackDiff() + " - " + currStackSize +  " - " +  currentMax);

        }

        stackInst.setInstruction(stackInst.getInstruction().replace("#",String.valueOf(currentMax))) ;

        return true;
    }

    public void startSemanthicAnalysis()  throws SemanticParseException, ParseException{

        if(this.treeRoot == null)
            return;

        this.symbolTable = new GeneralDescriptor();

        try {
            symbolTable.buildTable(this.treeRoot);
        } catch (IllegalArgumentException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        if(Main.showST)
            System.out.println(this.symbolTable.toString());
        // System.out.println("Starting analysis:");
        HashSet<String> variables =  new HashSet<String>();
        try {
            this.treeRoot.analyze(this.symbolTable, variables);
        } catch (SemanticParseException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        System.out.println(this.semanticWarningMessage);

        // Check if the maximum amount of errors as been reached
        if (this.semanticExceptionCount > 0) {
            throw new SemanticParseException(semanticErrorMessage, semanticExceptionCount);
        }

    }

    public void writeLine(String line){

        if(this.outputFile == null){
            return;
        }

        try{

            this.outputFile.write(line + "\n");
        }
        catch(IOException ex){

            ex.printStackTrace();
        }
    }

    public void startCodeGeneration(String fileName, String destDir) {

        if(this.fileName == null || this.treeRoot == null){
            System.out.println("Cannot generate code. Syntatic and semantic anlysis needed.");
        }

        try{
            File dir = new File(destDir);
            dir.mkdirs();
            File file = new File(destDir + fileName);
            this.outputFile = new BufferedWriter(new FileWriter(file));
            this.treeRoot.generateCode(this.symbolTable);

            for(int i = 0; i < this.generatedLines.size(); i++){
                this.writeLine(this.generatedLines.get(i).getInstruction());
            }

            this.outputFile.close();
        }
        catch(IOException ex){

            ex.printStackTrace();
        }
    }

    public String getLabel() {
        lastLabelID++;
        return "l" + lastLabelID;
    }
}

PARSER_END(Parser)


SKIP: {
    " " | "\t" | "\r" | "\n"
}

TOKEN: {
    <IF: "if" >
    | <ELSE: "else" >
    | <PUBLIC: "public" >
    | <NEW: "new" >
    | <INT: "int" >
    | <TRUE: "true" >
    | <THIS: "this" >
    | <VOID: "void" >
    | <MAIN: "main" >
    | <STRINGARR: "String[]" >
    | <FALSE: "false" >
    | <CLASS: "class" >
    | <STATIC: "static" >
    | <LENGTH: "length" >
    | <RETURN: "return" >
    | <IMPORT: "import" >
    | <BOOLEAN: "boolean" >
    | <EXTENDS: "extends" >
    | <WHILE: "while" >
    | <LBRACKET: "{" >
    | <RBRACKET: "}" >
    | <LPAR: "(" >
    | <RPAR: ")" >
    | <LSQRBRACKET: "[" >
    | <RSQRBRACKET: "]" >
    | <SCOLON: ";" >
    | <COMMA: "," >
    | <EQUALS: "=" >
    | <AND: "&&" >
    | <LESS: "<" >
    | <PLUS: "+" >
    | <MINUS: "-" >
    | <MUL: "*" >
    | <DIV: "/" >
    | <DOT: "." >
    | <NOT: "!" >
    | <IDENTIFIER: ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])* >
    | <NUMERIC: (["0"-"9"])+ >
}

/*
 * Comments
 */
<DEFAULT> MORE : { "//" : IN_SINGLE_LINE_COMMENT
                 | <"/**" ~["/"]> : IN_FORMAL_COMMENT
                 | "/*" : IN_MULTI_LINE_COMMENT
                 | "/*@bgen(jjtree" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN : {
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN : {
    <FORMAL_COMMENT: "*/"> : DEFAULT
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN : {
    <MULTI_LINE_COMMENT: "*/"> : DEFAULT
}

<IN_SINGLE_LINE_COMMENT, IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT> MORE : {
    <~[]>
}

/**
 * Grammar productions
 */

SimpleNode Program() : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(this, JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    // Reset error tracking
    {
        this.syntatcicExceptionCount = 0;
        this.syntacticErrorMessage = "";
        this.parenthesisCount = 0;
    }

    try {
        Imports() ClassDeclaration() <EOF>
    } catch (ParseException e) {
        // Add new error message to previous error messages and end the execution.
        this.syntatcicExceptionCount++;
        if (syntatcicExceptionCount > 0) {
            throw new ParseException(e, syntacticErrorMessage, syntatcicExceptionCount);
        }
    }/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/

    {
        // Check if any while expression error messages were caught
        if (syntatcicExceptionCount > 0) {
            throw new ParseException(syntacticErrorMessage, syntatcicExceptionCount);
        }

        this.treeRoot = jjtn000;
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Imports()       : {}
{
    (Import() <SCOLON>)*
}

// void ImportDeclaration() #void : {}
// {
//     <IMPORT>
//     (
//         ImportStatic()
//     |
//         ImportNotStatic()
//     )
//     <SCOLON>
// }

// void ImportStatic() #Import : { Token t; }
// {
//     <STATIC> { jjtThis.setStatic(true); }

//     t = <IDENTIFIER> { jjtThis.setClassName(t.image); }
//     <DOT>
//     t = <IDENTIFIER> { jjtThis.setMethodName(t.image); }

//     ImportParams()
// }

// void ImportNotStatic() #Import : { Token t; }
// {
//     t = <IDENTIFIER> { jjtThis.setClassName(t.image); } // if it only has one identifier, it's a constructor
//     (
//         <DOT>
//         t = <IDENTIFIER> { jjtThis.setMethodName(t.image); }

//         ImportParams()
//     )?
// }

// void ImportParams() #void : {}
// {
//     <LPAR> {
//         this.parenthesisCount++;
//     }

//     ((Type() (<COMMA> Type())*) | <VOID>)? #ParamList

//     <RPAR> {
//         this.parenthesisCount--;
//     }

//     (Type() | <VOID>)? #Return // if return type doesn't exist, assume it's void
// }

void Import(): {/*@bgen(jjtree) Import */
                ASTImport jjtn000 = new ASTImport(this, JJTIMPORT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
                jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t;}{/*@bgen(jjtree) Import */
    try {
/*@egen*/
    <IMPORT> [<STATIC> {jjtn000.setStatic(true);}] t=<IDENTIFIER>{jjtn000.setClassName(t.image);} [<DOT> t=<IDENTIFIER> {jjtn000.setMethodName(t.image);}]
     ([ <LPAR> { this.parenthesisCount++; }
        ParamList()
        <RPAR> { this.parenthesisCount--; }/*@bgen(jjtree) Return */
        {
          ASTReturn jjtn001 = new ASTReturn(this, JJTRETURN);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/
        [Type()|<VOID>]/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
            jjtn001.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/         ])/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ParamList(): {/*@bgen(jjtree) ParamList */
  ASTParamList jjtn000 = new ASTParamList(this, JJTPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/} {/*@bgen(jjtree) ParamList */
    try {
/*@egen*/
    [Type()  (<COMMA> Type())*]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ClassDeclaration()        : {/*@bgen(jjtree) Class */
                                   ASTClass jjtn000 = new ASTClass(this, JJTCLASS);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
                                   jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ Token t;}
{/*@bgen(jjtree) Class */
    try {
/*@egen*/
    <CLASS>
    t = <IDENTIFIER> { jjtn000.value = t.image; }
    (
        <EXTENDS> t = <IDENTIFIER>/*@bgen(jjtree) Extends */
                                   {
                                     ASTExtends jjtn001 = new ASTExtends(this, JJTEXTENDS);
                                     boolean jjtc001 = true;
                                     jjtree.openNodeScope(jjtn001);
                                     jjtn001.jjtSetFirstToken(getToken(1));
                                   }
                                   try {
/*@egen*//*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn001, true);
                                     jjtc001 = false;
                                     jjtn001.jjtSetLastToken(getToken(0));
                                   }
/*@egen*/ { jjtn001.value = t.image; }/*@bgen(jjtree)*/
                                   } finally {
                                     if (jjtc001) {
                                       jjtree.closeNodeScope(jjtn001, true);
                                       jjtn001.jjtSetLastToken(getToken(0));
                                     }
                                   }
/*@egen*/         
    )?
    <LBRACKET>
    (VarDeclaration() <SCOLON>)*
    (MethodDeclaration())*
    <RBRACKET>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void VarDeclaration()                    : {/*@bgen(jjtree) #VarDeclaration( 2) */
  ASTVarDeclaration jjtn000 = new ASTVarDeclaration(this, JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ }
{/*@bgen(jjtree) #VarDeclaration( 2) */
    try {
/*@egen*/
    Type() Identifier()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void MethodDeclaration()         : {/*@bgen(jjtree) Method */
                                     ASTMethod jjtn000 = new ASTMethod(this, JJTMETHOD);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
                                     jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ Token t; }
{/*@bgen(jjtree) Method */
    try {
/*@egen*/
    <PUBLIC>
    (
        Type()
        t = <IDENTIFIER> { jjtn000.value = t.image; }
        <LPAR> { this.parenthesisCount++; }/*@bgen(jjtree) ParamList */
        {
          ASTParamList jjtn001 = new ASTParamList(this, JJTPARAMLIST);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/
        (
            VarDeclaration()
            (
                <COMMA> VarDeclaration()
            )*
        )?/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
            jjtn001.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/           
        <RPAR> { this.parenthesisCount--; }
        <LBRACKET>/*@bgen(jjtree) Body */
        {
          ASTBody jjtn002 = new ASTBody(this, JJTBODY);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
          jjtn002.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/
        MethodBody()/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
            jjtn002.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/      
        <RETURN>/*@bgen(jjtree) #Return( 1) */
                 {
                   ASTReturn jjtn003 = new ASTReturn(this, JJTRETURN);
                   boolean jjtc003 = true;
                   jjtree.openNodeScope(jjtn003);
                   jjtn003.jjtSetFirstToken(getToken(1));
                 }
                 try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                 } catch (Throwable jjte003) {
                   if (jjtc003) {
                     jjtree.clearNodeScope(jjtn003);
                     jjtc003 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte003 instanceof RuntimeException) {
                     throw (RuntimeException)jjte003;
                   }
                   if (jjte003 instanceof ParseException) {
                     throw (ParseException)jjte003;
                   }
                   throw (Error)jjte003;
                 } finally {
                   if (jjtc003) {
                     jjtree.closeNodeScope(jjtn003,  1);
                     jjtn003.jjtSetLastToken(getToken(0));
                   }
                 }
/*@egen*/            <SCOLON>
        <RBRACKET>
    |
        <STATIC>
        <VOID>
        t = <MAIN> {jjtn000.value = t.image;
                    jjtn000.isStatic = true;
        }
        <LPAR> { this.parenthesisCount++; }/*@bgen(jjtree) ParamList */
        {
          ASTParamList jjtn006 = new ASTParamList(this, JJTPARAMLIST);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
          jjtn006.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/
        (/*@bgen(jjtree) #VarDeclaration( 2) */
            {
              ASTVarDeclaration jjtn005 = new ASTVarDeclaration(this, JJTVARDECLARATION);
              boolean jjtc005 = true;
              jjtree.openNodeScope(jjtn005);
              jjtn005.jjtSetFirstToken(getToken(1));
            }
            try {
/*@egen*/
            (
                t = <STRINGARR>/*@bgen(jjtree) Type */
                                {
                                  ASTType jjtn004 = new ASTType(this, JJTTYPE);
                                  boolean jjtc004 = true;
                                  jjtree.openNodeScope(jjtn004);
                                  jjtn004.jjtSetFirstToken(getToken(1));
                                }
                                try {
/*@egen*//*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn004, true);
                                  jjtc004 = false;
                                  jjtn004.jjtSetLastToken(getToken(0));
                                }
/*@egen*/ { jjtn004.value = t.image; }/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc004) {
                                    jjtree.closeNodeScope(jjtn004, true);
                                    jjtn004.jjtSetLastToken(getToken(0));
                                  }
                                }
/*@egen*/      
                Identifier()
            )/*@bgen(jjtree)*/
            } catch (Throwable jjte005) {
              if (jjtc005) {
                jjtree.clearNodeScope(jjtn005);
                jjtc005 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte005 instanceof RuntimeException) {
                throw (RuntimeException)jjte005;
              }
              if (jjte005 instanceof ParseException) {
                throw (ParseException)jjte005;
              }
              throw (Error)jjte005;
            } finally {
              if (jjtc005) {
                jjtree.closeNodeScope(jjtn005,  2);
                jjtn005.jjtSetLastToken(getToken(0));
              }
            }
/*@egen*/                   
        )/*@bgen(jjtree)*/
        } catch (Throwable jjte006) {
          if (jjtc006) {
            jjtree.clearNodeScope(jjtn006);
            jjtc006 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte006 instanceof RuntimeException) {
            throw (RuntimeException)jjte006;
          }
          if (jjte006 instanceof ParseException) {
            throw (ParseException)jjte006;
          }
          throw (Error)jjte006;
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
            jjtn006.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/           
        <RPAR> { this.parenthesisCount--; }
        <LBRACKET>/*@bgen(jjtree) Body */
        {
          ASTBody jjtn007 = new ASTBody(this, JJTBODY);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
          jjtn007.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/
        MethodBody()/*@bgen(jjtree)*/
        } catch (Throwable jjte007) {
          if (jjtc007) {
            jjtree.clearNodeScope(jjtn007);
            jjtc007 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte007 instanceof RuntimeException) {
            throw (RuntimeException)jjte007;
          }
          if (jjte007 instanceof ParseException) {
            throw (ParseException)jjte007;
          }
          throw (Error)jjte007;
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
            jjtn007.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/      
        <RBRACKET>
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void MethodBody()       : { Token t; }
{/*@bgen(jjtree) #VarDeclaration( 2) */
    {
      ASTVarDeclaration jjtn001 = new ASTVarDeclaration(this, JJTVARDECLARATION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*/
    (
        TypeNoId()
        Identifier()
        <SCOLON>
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtn001.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/                   
    MethodBody()
|
    t = <IDENTIFIER> StartsWithId(t)
|
    NotIdStatement() Statements()
|
    {}
}

void StartsWithId(Token t2)       : { Token t; }
{/*@bgen(jjtree) #VarDeclaration( 2) */
    {
      ASTVarDeclaration jjtn003 = new ASTVarDeclaration(this, JJTVARDECLARATION);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
      jjtn003.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*/
    (/*@bgen(jjtree) Type */
     {
       ASTType jjtn001 = new ASTType(this, JJTTYPE);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
       jjtn001.jjtSetFirstToken(getToken(1));
     }
     try {
/*@egen*//*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn001, true);
       jjtc001 = false;
       jjtn001.jjtSetLastToken(getToken(0));
     }
/*@egen*/{ jjtn001.value = t2.image; }/*@bgen(jjtree)*/
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001, true);
         jjtn001.jjtSetLastToken(getToken(0));
       }
     }
/*@egen*/      
    t = <IDENTIFIER> <SCOLON>/*@bgen(jjtree) Identifier */
                              {
                                ASTIdentifier jjtn002 = new ASTIdentifier(this, JJTIDENTIFIER);
                                boolean jjtc002 = true;
                                jjtree.openNodeScope(jjtn002);
                                jjtn002.jjtSetFirstToken(getToken(1));
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn002, true);
                                jjtc002 = false;
                                jjtn002.jjtSetLastToken(getToken(0));
                              }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc002) {
                                  jjtree.closeNodeScope(jjtn002, true);
                                  jjtn002.jjtSetLastToken(getToken(0));
                                }
                              }
/*@egen*/            )/*@bgen(jjtree)*/
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  2);
        jjtn003.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/                    MethodBody()
|/*@bgen(jjtree) Identifier */
    {
      ASTIdentifier jjtn004 = new ASTIdentifier(this, JJTIDENTIFIER);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
      jjtn004.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn004, true);
      jjtc004 = false;
      jjtn004.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    { jjtn004.value = t2.image; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004, true);
        jjtn004.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/             StatementAfterId() <SCOLON> Statements()
}

/**
 * Statement productions
 */
void Statements()       : {}
{
    (Statement())*
}

void Statement()       : {}
{
    NotIdStatement()
|
    IdStatement()
}

void NotIdStatement()       : {}
{
    <LBRACKET>/*@bgen(jjtree) Scope */
               {
                 ASTScope jjtn001 = new ASTScope(this, JJTSCOPE);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
                 jjtn001.jjtSetFirstToken(getToken(1));
               }
               try {
/*@egen*/ (Statement())*/*@bgen(jjtree)*/
               } catch (Throwable jjte001) {
                 if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   throw (RuntimeException)jjte001;
                 }
                 if (jjte001 instanceof ParseException) {
                   throw (ParseException)jjte001;
                 }
                 throw (Error)jjte001;
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                   jjtn001.jjtSetLastToken(getToken(0));
                 }
               }
/*@egen*/        <RBRACKET>
|
    IfStatement()
|
    WhileLoop()
|
    ExpressionNotID() <SCOLON>
}

void IdStatement()       : {}
{
    Identifier() StatementAfterId() <SCOLON>
}

void StatementAfterId()       : {}
{
    <EQUALS>/*@bgen(jjtree) #Assignment( 2) */
             {
               ASTAssignment jjtn001 = new ASTAssignment(this, JJTASSIGNMENT);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
               jjtn001.jjtSetFirstToken(getToken(1));
             }
             try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
                 jjtn001.jjtSetLastToken(getToken(0));
               }
             }
/*@egen*/               
|
    ArrayAccess() ArrayStatement()
|
    ExpNotArray()
}

void IfStatement() : {/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
    try {
/*@egen*/
    <IF> Condition() Statement()
    <ELSE> Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void WhileLoop()        : {/*@bgen(jjtree) While */
  ASTWhile jjtn000 = new ASTWhile(this, JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) While */
    try {
/*@egen*/
    try {
        <WHILE> Condition()
    } catch (ParseException e) {
        handleWhileConditionError(e);
    }

    Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Condition()            : {/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(this, JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Condition */
    try {
/*@egen*/
    <LPAR> { this.parenthesisCount++; }
    Expression()
    <RPAR>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtn000.jjtSetLastToken(getToken(0));
           }
/*@egen*/ { this.parenthesisCount--; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Identifier()             : {/*@bgen(jjtree) Identifier */
                                  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
                                  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ Token t; }
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t = <IDENTIFIER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                       jjtn000.jjtSetLastToken(getToken(0));
                     }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Type()       : { Token t; }
{
    t = <IDENTIFIER>/*@bgen(jjtree) Type */
                     {
                       ASTType jjtn001 = new ASTType(this, JJTTYPE);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                       jjtn001.jjtSetFirstToken(getToken(1));
                     }
                     try {
/*@egen*//*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn001, true);
                       jjtc001 = false;
                       jjtn001.jjtSetLastToken(getToken(0));
                     }
/*@egen*/ { jjtn001.value = t.image; }/*@bgen(jjtree)*/
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001, true);
                         jjtn001.jjtSetLastToken(getToken(0));
                       }
                     }
/*@egen*/      
|
    TypeNoId()
}

void TypeNoId()       : {/*@bgen(jjtree) Type */
                          ASTType jjtn000 = new ASTType(this, JJTTYPE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
                          jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ Token t; Boolean b = false; }
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    t = <BOOLEAN>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.jjtSetLastToken(getToken(0));
                  }
/*@egen*/ { jjtn000.value = t.image; }
|
    (
        t = <INT> (<LSQRBRACKET> <RSQRBRACKET> { b = true; } )?/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                  jjtn000.jjtSetLastToken(getToken(0));
                                                                }
/*@egen*/ {
            if (b)
                jjtn000.value = t.image + "[]";
            else
                jjtn000.value = t.image;
        }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ArrayStatement()       : {}
{
    <EQUALS>/*@bgen(jjtree) #Assignment( 2) */
             {
               ASTAssignment jjtn001 = new ASTAssignment(this, JJTASSIGNMENT);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
               jjtn001.jjtSetFirstToken(getToken(1));
             }
             try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
                 jjtn001.jjtSetLastToken(getToken(0));
               }
             }
/*@egen*/               
|
    ExpNoLeftTerminal()
}

void DotMethod()             : {/*@bgen(jjtree) Identifier */
                                 ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
                                 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/ Token t; }
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t = <LENGTH>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtn000.jjtSetLastToken(getToken(0));
                 }
/*@egen*/ { jjtn000.value = t.image; }
|
    t = <IDENTIFIER> { jjtn000.value = t.image; }
    <LPAR> { this.parenthesisCount++; }
    (Expression() (<COMMA> Expression())*)?
    <RPAR>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtn000.jjtSetLastToken(getToken(0));
           }
/*@egen*/ { this.parenthesisCount--; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ArrayAccess()                 : {/*@bgen(jjtree) #ArrayAccess( 2) */
  ASTArrayAccess jjtn000 = new ASTArrayAccess(this, JJTARRAYACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) #ArrayAccess( 2) */
    try {
/*@egen*/
    <LSQRBRACKET> Expression() <RSQRBRACKET>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

/**
 * Expression productions
 */
void Expression()       : {}
{
    Exp1() ExpressionPrime()
}

void ExpressionPrime()       : {}
{
    <AND>/*@bgen(jjtree) #And( 2) */
          {
            ASTAnd jjtn001 = new ASTAnd(this, JJTAND);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            jjtn001.jjtSetFirstToken(getToken(1));
          }
          try {
/*@egen*/ Exp1()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtn001.jjtSetLastToken(getToken(0));
            }
          }
/*@egen*/         ExpressionPrime()
|
    {}
}

void Exp1()       : {}
{
    Exp2() Exp1Prime()
}

void Exp1Prime()       : {}
{
    <LESS>/*@bgen(jjtree) #Less( 2) */
           {
             ASTLess jjtn001 = new ASTLess(this, JJTLESS);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtn001.jjtSetFirstToken(getToken(1));
           }
           try {
/*@egen*/ Exp2()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
               jjtn001.jjtSetLastToken(getToken(0));
             }
           }
/*@egen*/          Exp1Prime()
|
    {}
}

void Exp2()       : {}
{
    Exp3() Exp2Prime()
}

void Exp2Prime()       : {}
{
    <PLUS>/*@bgen(jjtree) #Add( 2) */
           {
             ASTAdd jjtn001 = new ASTAdd(this, JJTADD);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtn001.jjtSetFirstToken(getToken(1));
           }
           try {
/*@egen*/ Exp3()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
               jjtn001.jjtSetLastToken(getToken(0));
             }
           }
/*@egen*/         Exp2Prime()
|
    <MINUS>/*@bgen(jjtree) #Sub( 2) */
            {
              ASTSub jjtn002 = new ASTSub(this, JJTSUB);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtn002.jjtSetFirstToken(getToken(1));
            }
            try {
/*@egen*/ Exp3()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
                jjtn002.jjtSetLastToken(getToken(0));
              }
            }
/*@egen*/         Exp2Prime()
|
    {}
}

void Exp3()       : {}
{
    Exp4() Exp3Prime()
}

void Exp3Prime()       : {}
{
    <MUL>/*@bgen(jjtree) #Mul( 2) */
          {
            ASTMul jjtn001 = new ASTMul(this, JJTMUL);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            jjtn001.jjtSetFirstToken(getToken(1));
          }
          try {
/*@egen*/ Exp4()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtn001.jjtSetLastToken(getToken(0));
            }
          }
/*@egen*/         Exp3Prime()
|
    <DIV>/*@bgen(jjtree) #Div( 2) */
          {
            ASTDiv jjtn002 = new ASTDiv(this, JJTDIV);
            boolean jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
            jjtn002.jjtSetFirstToken(getToken(1));
          }
          try {
/*@egen*/ Exp4()/*@bgen(jjtree)*/
          } catch (Throwable jjte002) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte002 instanceof RuntimeException) {
              throw (RuntimeException)jjte002;
            }
            if (jjte002 instanceof ParseException) {
              throw (ParseException)jjte002;
            }
            throw (Error)jjte002;
          } finally {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
              jjtn002.jjtSetLastToken(getToken(0));
            }
          }
/*@egen*/         Exp3Prime()
|
    {}
}

void Exp4()       : {}
{
    Exp5() Exp4Prime()
}

void Exp4Prime()       : {}
{
    <DOT>/*@bgen(jjtree) #MethodCall( 2) */
          {
            ASTMethodCall jjtn001 = new ASTMethodCall(this, JJTMETHODCALL);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            jjtn001.jjtSetFirstToken(getToken(1));
          }
          try {
/*@egen*/ DotMethod()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  2);
              jjtn001.jjtSetLastToken(getToken(0));
            }
          }
/*@egen*/                Exp5Prime() Exp4Prime()
|
    {}
}

void Exp5()       : {}
{
    ExpTerminal() Exp5Prime()
}

void Exp5Prime()       : {}
{
    ArrayAccess() Exp5Prime()
|
    {}
}

/**
 * Expression that doesn't accept an identifier as its leftmost terminal
 */
void ExpressionNotID()       : {}
{
    Exp1NotID() ExpressionPrime()
}

void Exp1NotID()       : {}
{
    Exp2NotID() Exp1Prime()
}

void Exp2NotID()       : {}
{
    Exp3NotID() Exp2Prime()
}

void Exp3NotID()       : {}
{
    Exp4NotID() Exp3Prime()
}

void Exp4NotID()       : {}
{
    Exp5NotID() Exp4Prime()
}

void Exp5NotID()       : {}
{
    ExpTerminalNotID() Exp5Prime()
}

/**
 * Expression that can't have an array access at the leftmost position
 */
void ExpNotArray()       : {}
{
    Exp1NotArray() ExpressionPrime()
}

void Exp1NotArray()       : {}
{
    Exp2NotArray() Exp1Prime()
}

void Exp2NotArray()       : {}
{
    Exp3NotArray() Exp2Prime()
}

void Exp3NotArray()       : {}
{
    Exp4Prime() Exp3Prime()
}

/**
 * Expression that doesn't have a left most "terminal" (i. e. starts with an operator)
 */
void ExpNoLeftTerminal()       : {}
{
    Exp1NoLeftTerminal() ExpressionPrime()
}

void Exp1NoLeftTerminal()       : {}
{
    Exp2NoLeftTerminal() Exp1Prime()
}

void Exp2NoLeftTerminal()       : {}
{
    Exp3NoLeftTerminal() Exp2Prime()
}

void Exp3NoLeftTerminal()       : {}
{
    Exp4NoLeftTerminal() Exp3Prime()
}

void Exp4NoLeftTerminal()       : {}
{
    Exp5NoLeftTerminal() Exp4Prime()
}

void Exp5NoLeftTerminal()       : {}
{
    Exp5Prime()
}


void ExpTerminal()       : { Token t; }
{
    ExpTerminalNotID()
|
    Identifier()
}

void ExpTerminalNotID()       : { Token t; }
{
    <LPAR> { this.parenthesisCount++; } Expression() <RPAR> { this.parenthesisCount--; }
|
    <NOT>/*@bgen(jjtree) #Not( 1) */
          {
            ASTNot jjtn001 = new ASTNot(this, JJTNOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
            jjtn001.jjtSetFirstToken(getToken(1));
          }
          try {
/*@egen*/ (Exp5() Exp4Prime())/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  1);
              jjtn001.jjtSetLastToken(getToken(0));
            }
          }
/*@egen*/        
|
    t = <NUMERIC>/*@bgen(jjtree) Numeric */
                  {
                    ASTNumeric jjtn002 = new ASTNumeric(this, JJTNUMERIC);
                    boolean jjtc002 = true;
                    jjtree.openNodeScope(jjtn002);
                    jjtn002.jjtSetFirstToken(getToken(1));
                  }
                  try {
/*@egen*//*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn002, true);
                    jjtc002 = false;
                    jjtn002.jjtSetLastToken(getToken(0));
                  }
/*@egen*/ { jjtn002.value = t.image;}/*@bgen(jjtree)*/
                  } finally {
                    if (jjtc002) {
                      jjtree.closeNodeScope(jjtn002, true);
                      jjtn002.jjtSetLastToken(getToken(0));
                    }
                  }
/*@egen*/         
|
    t = <TRUE>/*@bgen(jjtree) Boolean */
               {
                 ASTBoolean jjtn003 = new ASTBoolean(this, JJTBOOLEAN);
                 boolean jjtc003 = true;
                 jjtree.openNodeScope(jjtn003);
                 jjtn003.jjtSetFirstToken(getToken(1));
               }
               try {
/*@egen*//*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn003, true);
                 jjtc003 = false;
                 jjtn003.jjtSetLastToken(getToken(0));
               }
/*@egen*/ { jjtn003.value = t.image; }/*@bgen(jjtree)*/
               } finally {
                 if (jjtc003) {
                   jjtree.closeNodeScope(jjtn003, true);
                   jjtn003.jjtSetLastToken(getToken(0));
                 }
               }
/*@egen*/         
|
    t = <FALSE>/*@bgen(jjtree) Boolean */
                {
                  ASTBoolean jjtn004 = new ASTBoolean(this, JJTBOOLEAN);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                  jjtn004.jjtSetFirstToken(getToken(1));
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn004, true);
                  jjtc004 = false;
                  jjtn004.jjtSetLastToken(getToken(0));
                }
/*@egen*/ { jjtn004.value = t.image; }/*@bgen(jjtree)*/
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004, true);
                    jjtn004.jjtSetLastToken(getToken(0));
                  }
                }
/*@egen*/         
|/*@bgen(jjtree) This */
    {
      ASTThis jjtn005 = new ASTThis(this, JJTTHIS);
      boolean jjtc005 = true;
      jjtree.openNodeScope(jjtn005);
      jjtn005.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*/
    <THIS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc005) {
        jjtree.closeNodeScope(jjtn005, true);
        jjtn005.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/      
|
    <NEW>/*@bgen(jjtree) New */
    {
      ASTNew jjtn008 = new ASTNew(this, JJTNEW);
      boolean jjtc008 = true;
      jjtree.openNodeScope(jjtn008);
      jjtn008.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*/
    (
        t = <INT> <LSQRBRACKET> Expression() <RSQRBRACKET>/*@bgen(jjtree) #Type( 1) */
        {
          ASTType jjtn006 = new ASTType(this, JJTTYPE);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
          jjtn006.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn006,  1);
          jjtc006 = false;
          jjtn006.jjtSetLastToken(getToken(0));
        }
/*@egen*/
        { jjtn006.value = t.image + "[]"; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006,  1);
            jjtn006.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/         
    |
        t = <IDENTIFIER>
        <LPAR> { this.parenthesisCount++; }/*@bgen(jjtree) Type */
        {
          ASTType jjtn007 = new ASTType(this, JJTTYPE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
          jjtn007.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/
        ((Expression() (<COMMA> Expression())*)?/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn007, true);
                                                   jjtc007 = false;
                                                   jjtn007.jjtSetLastToken(getToken(0));
                                                 }
/*@egen*/ { jjtn007.value = t.image;  })/*@bgen(jjtree)*/
        } catch (Throwable jjte007) {
          if (jjtc007) {
            jjtree.clearNodeScope(jjtn007);
            jjtc007 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte007 instanceof RuntimeException) {
            throw (RuntimeException)jjte007;
          }
          if (jjte007 instanceof ParseException) {
            throw (ParseException)jjte007;
          }
          throw (Error)jjte007;
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
            jjtn007.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/      
        <RPAR>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn008, true);
                 jjtc008 = false;
                 jjtn008.jjtSetLastToken(getToken(0));
               }
/*@egen*/ { this.parenthesisCount--; }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte008) {
      if (jjtc008) {
        jjtree.clearNodeScope(jjtn008);
        jjtc008 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte008 instanceof RuntimeException) {
        throw (RuntimeException)jjte008;
      }
      if (jjte008 instanceof ParseException) {
        throw (ParseException)jjte008;
      }
      throw (Error)jjte008;
    } finally {
      if (jjtc008) {
        jjtree.closeNodeScope(jjtn008, true);
        jjtn008.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/     
}